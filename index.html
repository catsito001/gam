<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive English Stories</title>
  
  <!-- Fuentes e Íconos -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
  
  <!-- Axios para cargar la data -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  
  <style>
    /* Variables y estilos base - Modo Oscuro */
    :root {
      --primary-600: #6366f1;
      --primary-500: #818cf8;
      --primary-600-hover: #4f46e5;
      --accent: #ef4444;
      --surface-100: #1a1a1a;
      --text-primary: #e5e7eb;
      --radius-md: 12px;
      --shadow-md: 0 4px 6px rgba(0,0,0,0.3);
      --transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
      --grid-gap: 10px;
      --gradient-purple: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      --gradient-teal: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
    }
    
    /* Reset y estilos generales */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Inter', sans-serif; 
      background-color: #121212; 
      color: var(--text-primary); 
      margin-top: -15px;
    }
    
    /* ============================ */
    /* Botones Interactivos         */
    /* ============================ */
    .btn-professional {
      background: var(--gradient-purple);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 6px 12px;
      font-weight: 600;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
      transition: var(--transition);
      box-shadow: 0 4px 15px rgba(99,102,241,0.3);
      cursor: pointer;
    }
    .btn-professional::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 200%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: 0.5s;
    }
    .btn-professional:hover {
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 6px 20px rgba(99,102,241,0.4);
    }
    .btn-professional:hover::after { left: 100%; }
    
    /* ============================ */
    /* Loading Screen               */
    /* ============================ */
    .loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--surface-100);
  display: grid; /* Centrado con grid */
  place-items: center;
  z-index: 9999;
}
    .spinner {
      width: 48px;
      height: 48px;
      border: 3px solid #e2e8f0;
      border-top-color: var(--primary-500);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* ============================ */
    /* Stories List                 */
    /* ============================ */
    .stories-view { 
      max-width: 1400px; 
      margin: 0 auto; 
      padding: 1rem; 
    }
    .stories-header { 
      text-align: center; 
      padding: 1rem 0; 
    }
    .stories-header h1 { 
      font-size: 2.5rem; 
      font-weight: 700; 
    }
    .stories-header p { 
      color: var(--text-primary); 
    }
    .stories-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 0.5rem;
      padding: 1px 0;
    }
    /* Tarjeta de historia */
    .story-card {
      background: #2d2d2d;
      border: 1px solid #3d3d3d;
      border-radius: var(--radius-md);
      padding: 0.5rem;
      transition: var(--transition);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
      text-align: center;
    }
    .story-card::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: var(--gradient-purple);
      opacity: 0.1;
      transform: rotate(45deg);
      transition: opacity 0.3s;
    }
    .story-card:hover {
      transform: translateY(-5px) scale(1.02);
      border-color: var(--primary-500);
    }
    .story-card:hover::before { opacity: 0.15; }
    .story-card h3 { 
      color: #fff; 
      font-size: 1.4rem; 
      margin-bottom: 0.5rem; 
      position: relative; 
      z-index: 1; 
    }
    .story-card p { 
      color: #a1a1aa; 
      font-size: 0.95rem; 
      position: relative; 
      z-index: 1; 
    }
    
    /* ============================ */
    /* Story View                   */
    /* ============================ */
    .story-view {
      max-width: 800px;
      margin: 1rem auto;
      background: #1f1f1f;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      display: flex;
      flex-direction: column;
    }
    .story-header {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      background: #1f1f1f;
      border-bottom: 1px solid #3d3d3d;
    }
    .header-left { 
      display: flex;
  flex-direction: column;
  align-items: flex-start; /* Si deseas que ambos queden a la izquierda */
    }
    .header-left button {
      background: var(--gradient-purple);
      color: white;
      border: none;
      width: 50px;
      height: 35px;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: var(--transition);
    }
    .header-left button:hover { transform: scale(1.1); }
    .header-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      font-weight: 600;
      text-align: left;
      white-space: normal;
      margin-left: 10px;

    }
    .header-content { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
    }
    .header-right { 
      margin-top: 0.5rem; 
      display: flex; 
      justify-content: flex-end; 
    }
    .progress-container {
      margin-top: 0.3rem;
      width: 100%;
      max-width: 250px;
      height: 12px;
      position: relative;
    }
    .progress-bar {
      width: 100%;
      height: 100%;
      background: #333;
      border-radius: 6px;
      overflow: hidden;
      margin-left: 10px;
    }
    .progress {
      height: 100%;
      width: 0;
      background: var(--gradient-purple);
      transition: width 0.4s ease-out;
    }
    .progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.9rem;
      color: var(--text-primary);
    }
    .story-content { 
      padding: 0.5rem; 
      flex: 1; 
      background: #181818;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .text-cards-container { width: 100%; }
    .text-card {
      display: none;
      padding: 0.5rem;
      background: #181818;
      border: 1px solid #3d3d3d;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      margin-bottom: 0.1rem;
    }
    .text-card.active { display: block; }
    .sentence-container { margin-bottom: 0.1rem; }
    .english-text {
      font-size: 1.4rem;
      line-height: 2.4rem;
      margin: 0.5rem 0;
      position: relative;
      background: #292828;
      border-radius: 5px;
      padding: 3px 3px 3px 3px;
      
    }
    .full-translation {
      font-size: 0.8rem;
      background: #333;
      color: #d1d5db;
      padding: 0.4rem;
      border-radius: var(--radius-md);
      margin-bottom: 0.5rem;
      border-left: 4px solid var(--primary-500);
    }
    /* Botones de toggle para traducciones y lista */
    .toggle-container { text-align: right; margin-top: 0.1rem; }
    .toggle-btn-wrapper { display: inline-block; }
    
    /* ============================ */
    /* Controles y Popups           */
    /* ============================ */
    .controls-footer {
      display: flex;
      justify-content: center;
      gap: 1rem;
      padding: 1rem;
      border-top: 1px solid #3d3d3d;
    }
    .control-btn {
      width: 60px;
      height: 60px;
      border: none;
      border-radius: var(--radius-md);
      background: var(--primary-500);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: var(--transition);
    }
    .control-btn:hover { transform: scale(1.1); }
    .word-popup, .saved-list-popup, .game-popup {
      background: #2d2d2d;
      border: 1px solid #3d3d3d;
      box-shadow: 0 12px 32px rgba(0,0,0,0.3);
      border-radius: var(--radius-md);
      padding: 1rem;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      max-width: 90%;
      width: 300px;
      color: var(--text-primary);

      align-items: center;          /* Centra horizontalmente */
  justify-content: center;      /* Centra verticalmente */
  text-align: center;
    }

    
    .word-popup h2, .saved-list-popup h2, .game-popup h2 { margin-top: 0; }
    .popup-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .word-popup button, .saved-list-popup button, .game-popup button {
      background: var(--primary-500);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: background 0.3s;
      margin: 5px;
    }
    .word-popup button:hover, .saved-list-popup button:hover, .game-popup button:hover {
      background: var(--primary-600);
    }
    
    /* Popup para selección de juego */
    .game-popup {
      width: 90%;
      max-width: 400px;
    }
    .game-popup ul { list-style: none; padding: 0; margin: 0; }
    .game-popup li {
      margin: 10px 0;
      padding: 10px;
      background: #1f1f1f;
      border: 1px solid #3d3d3d;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .game-popup li:hover { background: #3d3d3d; }
    .game-popup button {
      margin-top: 1rem;
    }
    
    /* ============================ */
    /* Game View                    */
    /* ============================ */
    #gameView {
      display: none;
      height: 100vh;
      overflow: hidden;
      position: relative;
      background: #1a1a1a;
    }
    #gameView .exit-game {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.5rem;
      cursor: pointer;
      transition: background 0.3s;
      z-index: 101;
    }
    #gameView .exit-game:hover { background: #c0392b; }
    #gameContent { 
      height: 100%; 
      overflow: auto; 
      padding-top: 60px; 
      
      max-width: 1000px;
      margin: 0 auto;
    }
    
    /* ============================ */
    /* Estilos para Juegos          */
    /* ============================ */
    /* Juego 1: Ordenar Palabras */
    .ordering-game-card {
      background-color: #222;
      border: 1px solid #444;
      border-radius: var(--radius-md);
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      color: #fff;
      min-height: 450px;
      box-sizing: border-box;
      margin: 5px;
    }
    .ordering-game-card .card-header {
      padding: 15px;
      text-align: center;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .ordering-game-title {
      margin: 0;
      font-size: 1.8rem;
      font-family: 'Orbitron', sans-serif;
    }
    .ordering-progress { font-size: 1rem; color: #bbb; }
    .ordering-game-card .card-body { padding: 15px; }
    .ordering-instruction { text-align: center; margin-bottom: 10px; font-size: 1.1rem; }
    .ordering-word-pool {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .ordering-word-pool .word-btn {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 20px;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .ordering-word-pool .word-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .ordering-word-pool .word-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, #2575fc, #6a11cb);
    }
    .ordering-answer-panel {
      min-height: 50px;
      padding: 100px 5px;
      margin-bottom: 15px;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      word-wrap: break-word;
    }
    .answer-word { font-size: 2.5rem; font-weight: bold; }
    .answer-translation {
      font-size: 0.9rem;
      color: #ccc;
      margin-top: 2px;
    }
    .ordering-response-title { text-align: center; margin-bottom: 10px; }
    .ordering-result { text-align: center; font-size: 1.2rem; font-weight: 500; margin-top: 10px; }
    .retry-btn {
      background: linear-gradient(135deg, #ff416c, #ff4b2b);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      margin: 10px auto;
      display: block;
    }
    .retry-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, #ff4b2b, #ff416c);
    }
    
    /* Juego 2: Trivia */
    .trivia-game-card {
      background-color: #222;
      border: 1px solid #444;
      border-radius: var(--radius-md);
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      color: #fff;
      min-height: 500px;
      box-sizing: border-box;
      margin: 5px;
    }
    .trivia-game-card .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
    .trivia-game-title {
      font-size: 1rem;
      font-family: 'Orbitron', sans-serif;
      margin: 0;
    }
    .trivia-progress { font-size: 1rem; color: #bbb; }
    .trivia-game-card .card-body { padding: 20px 0; }
    .trivia-options {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-bottom: 40px;
    }
    #game2Container .trivia-options .word-btn {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      width: 80%;
      max-width: 500px;
    }
    .trivia-options .word-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, #2575fc, #6a11cb);
    }
    .trivia-result {
      text-align: center;
      font-size: 1.5rem;
      margin-top: 10px;
      transition: all 0.3s ease;
    }


    .question {
      font-size: 1.5rem;
      font-family: 'Orbitron', sans-serif;
      margin: 50px;

    }
    @keyframes correctAnimation {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); }
    }
    @keyframes incorrectAnimation {
      0% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      50% { transform: translateX(5px); }
      75% { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }
    .animate-correct {
      animation: correctAnimation 0.5s ease;
      color: #00ff00;
    }
    .animate-incorrect {
      animation: incorrectAnimation 0.5s ease;
      color: #ff0000;
    }
    
    /* Juego 3: Memory Cards */
    #game3Container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      grid-auto-rows: 1fr;
      gap: 10px;
      justify-items: stretch;
      padding: 10px;
      height: 90%;
    }
    @media (max-width: 600px) {
      #game3Container { grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); }
    }
    .memory-card {
      width: 100%;
      height: 100%;
      background: #333;
      border: none;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      overflow: hidden;
      position: relative;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .memory-card:hover { 
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,0,0,0.2);
    }
    .card-back, .card-face {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .card-back {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      font-weight: bold;
      background: var(--gradient-purple);
      color: white;
    }
    .card-face { display: none; text-transform: uppercase; }
    .card-face .card-image {
      width: 100%;
      height: 60%;
      object-fit: cover;
    }
    .card-face .card-text {
      font-size: 1rem;
      font-weight: bold;
      padding: 5px;
      text-align: center;
    }
    
    /* Juego 4: Completa la Palabra */
    #game4Container {
      background-color: #222;
      border: 1px solid #444;
      border-radius: var(--radius-md);
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      color: #fff;
      min-height: 500px;
      box-sizing: border-box;
      margin: 5px;
    }
    #game4Container .incomplete-sentence {
      font-size: 2.5rem;
      text-align: center;
      margin-bottom: 30px;
      font-family: 'Roboto', sans-serif;
    }
    #game4Container .fill-answer {
      margin: 30px 0;
      font-size: 1.8rem;
      letter-spacing: 6px;
      text-transform: uppercase;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }
    #game4Container .fill-answer span {
      display: inline-block;
      min-width: 30px;
      border-bottom: 2px solid var(--primary-600);
      cursor: pointer;
      font-weight: bold;
      padding: 8px;
      text-align: center;
      transition: border-color 0.2s ease;
      font-family: 'Orbitron', sans-serif;
    }
    #game4Container .fill-answer span:hover { border-color: var(--primary-500); }
    #game4Container .letter-pool {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    #game4Container .letter-pool button {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      font-size: 1.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      width: 20%;
      max-width: 120px;
      text-transform: uppercase;
    }
    #game4Container .letter-pool button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    }
    #game4Container button.action-btn {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      margin: 20px auto;
      display: block;
    }
    #game4Container button.action-btn:hover {
      transform: translateY(-3px) scale(1.05);
      background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    }
    #game4Container #fillFeedback {
      text-align: center;
      font-size: 1.5rem;
      margin-top: 15px;
      font-weight: 500;
    }
    
    /* ============================ */
    /* Interacciones con Palabras   */
    /* ============================ */
    .highlight-word, .phrasal-verb-inline, .vocabulary-inline {
      position: relative;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .highlight-word.active,
    .phrasal-verb-inline.active,
    .vocabulary-inline.active {
      background: var(--primary-600);
      color: white;
    }
    .phrasal-verb-inline {
      display: inline-block;
      padding: 2px 4px;
      background-color: rgba(37,99,235,0.2);
      transition: background-color 0.3s ease;
    }
    .vocabulary-inline {
      background-color: rgba(16,185,129,0.2);
      transition: background-color 0.3s ease;
    }
    .translation-tooltip {
      position: absolute;
      bottom: 65%;
      left: 50%;
      transform: translateX(-50%);
      background: #50719b;
      color: #fff;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 0.7rem;
      white-space: nowrap;
      pointer-events: none;
      z-index: 10;
      margin-bottom: 4px;
      display: none;
      line-height: 0.8rem;
    }
    .phrasal-verb-inline .translation-tooltip {
      
      
    }
    .text-card.show-translations .english-text .translation-tooltip {
      display: block;
    }
    
    /* ============================ */
    /* Estilos de Vocabulario       */
    /* ============================ */
    .vocabulary-container { margin-top: 0.5rem; }
    .vocabulary-title { font-size: 0.9rem; margin-bottom: 0.3rem; color: #a1a1aa; }
    .vocabulary-words { 
      display: flex; 
      flex-wrap: nowrap; 
      gap: 0.5rem; 
      overflow-x: auto;
      scroll-behavior: smooth;
    }




    .select-voice {
  position: relative;
  
  padding: 5px 10px; /* Ajusta a lo que necesites */
  max-width: 50px;  /* O el ancho que prefieras para este select */
  background-color: #318c8f !important; /* Fondo sólido */
  /* Si prefieres gradiente, descomenta la siguiente línea y comenta la anterior */
  /* background: linear-gradient(135deg, #6366f1, #8b5cf6) !important; */
  color: white !important;
  border: none !important;
  border-radius: 8px !important;
  padding: 9px 9px 8px 15px !important; /* Espacio a la izquierda para el ícono y a la derecha para la flecha */
  font-size: 0.6rem;
  font-weight: 600;
  letter-spacing: 0.5px;
  cursor: pointer;
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  outline: none !important;
  background-image: none !important;
  display: inline-block;
  margin-right: 2px;
  margin-top: 8px;
}

    /* Contenedor de vocabulario: posición relativa para colocar botones */
.vocabulary-container {
  position: relative;
  margin-top: 0.5rem;
}

/* Título del vocabulario */
.vocabulary-title {
  font-size: 0.9rem;
  margin-bottom: 0.3rem;
  color: #a1a1aa;
}



/* Cada bloque de vocabulario no se encoge y se alinea al inicio de la vista */
.vocabulary-word {
  display: flex;
      align-items: center;
      background: #464161;
      padding: 0.4rem;
      border-radius: 4px;
      transition: background 0.3s;
      font-size: 0.8rem;
      
      gap: 0.1rem;
}

/* Botones de control del carrusel */
.vocab-carousel-control {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  padding: 0.3rem;
  cursor: pointer;
  z-index: 2;
}

.vocab-carousel-control.left {
  left: 0;
}

.vocab-carousel-control.right {
  right: 0;
}




    .vocabulary-word:hover { background: #3d3d3d; }
    .vocabulary-image {
      flex-shrink: 0;
      width: 50px;
      height: 50px;
      margin-right: 2px;
    }
    .vocabulary-image img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
    }
    .vocabulary-text { 
      display: flex; 
      flex-direction: column; 
      text-align: left; 
    }
    .vocabulary-text strong { font-weight: bold; }
    .vocabulary-translation { font-size: 0.7rem; color: #a1a1aa; }





    .header-right {
  margin-top: 0.5rem;
  display: flex;
  justify-content: flex-end;
  gap: 0.2rem;
}

.header-right .play-btn,
.header-right .saved-list-btn {
  border: none;
  border-radius: var(--radius-md);
  padding: 6px 6px;
  font-weight: 600;
  color: white;
  cursor: pointer;
  transition: background 0.3s;
  margin-right: 6px;
}

.header-right .play-btn {
  background: #10b981;
}

.header-right .play-btn:hover {
  background: #059669;
}

.header-right .saved-list-btn {
  background: var(--primary-500);
  display: flex;
  align-items: center;
}

.header-right .saved-list-btn:hover {
  background: var(--primary-600);
}

.header-right .saved-list-btn i {
  margin-right: 0.3rem;
}

.header-right .saved-list-btn span {
  background: white;
  color: var(--primary-500);
  border-radius: 50%;
  padding: 0 6px;
  font-size: 0.8rem;
  margin-left: 4px;
}








/* Carrusel de imágenes */
.carousel-container {
  position: relative;
  overflow: hidden;
  margin-bottom: 0.5rem;
}

.carousel-inner {
  display: flex;
  flex-direction: row;
  gap: 10px;
  transition: transform 0.5s ease;
  /* Se muestra horizontalmente sin wrap */
  flex-wrap: nowrap;
}

.carousel-item {
  flex-shrink: 0;
  width: 100%;
  display: none;
  justify-content: center;
  align-items: center;
}

.carousel-item.active {
  display: flex;
}

/* Botones de control del carrusel */
.carousel-control {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  padding: 0.5rem 0.75rem;
  cursor: pointer;
  z-index: 2;
}

.carousel-control.prev {
  left: 5px;
}

.carousel-control.next {
  right: 5px;
}

/* Estilos para las imágenes */
.story-image {
  /* Se adapta al tamaño del contenedor */
  max-height: 250px;   /* valor para escritorio, se ajusta en móviles con media queries */
  width: auto;
  object-fit: cover;
  border-radius: var(--radius-md);
  transition: transform 0.3s ease;
}

/* Responsividad: en móviles, reduce la altura pero mantiene la fila horizontal */
@media (max-width: 600px) {
  .story-image {
    max-height: 250px;
  }
}



/* En dispositivos móviles, se ajusta el tamaño de las imágenes sin romper la fila horizontal */
@media (max-width: 600px) {
  .story-image {
    max-height: 250px;    /* Menor altura para dispositivos pequeños */
    /* Puedes ajustar otros valores (p.ej. margenes o flex-basis) si lo crees necesario */
  }
}


.story-card:hover .story-image {
  transform: scale(1.05);
}

.image-container {
  display: flex;
  flex-direction: row;
  gap: 10px;
  overflow-x: auto;   /* Muestra scroll horizontal si es necesario */
  flex-wrap: nowrap;  /* Evita que se envuelvan a una nueva línea */
  justify-content: flex-start;
  padding: 0.5rem;
    }



/* Forzar que el select tenga apariencia de botón */
.custom-select {
  background-color: #6366f1 !important; /* Fondo sólido */
  /* Si prefieres gradiente, descomenta la siguiente línea y comenta la anterior */
  /* background: linear-gradient(135deg, #6366f1, #8b5cf6) !important; */
  color: white !important;
  border: none !important;
  border-radius: 8px !important;
  padding: 8px 30px 8px 23px !important; /* Espacio a la izquierda para el ícono y a la derecha para la flecha */
  font-size: 0.6rem;
  font-weight: 600;
  letter-spacing: 0.5px;
  cursor: pointer;
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  outline: none !important;
  background-image: none !important;
}

/* Elimina el outline al enfocar */
.custom-select:focus {
  outline: none !important;
}

/* Estilos para las opciones (nota: algunos navegadores ignoran estos estilos) */
.custom-select option {
  background-color: #6366f1;
  color: white;
}

/* Contenedor del select para agrupar el ícono y eliminar la flecha nativa */
.select-wrapper {
  position: relative;
  display: inline-block;
  margin-right: 2px;
}

/* Ícono de velocidad a la izquierda */
.speed-icon {
  position: absolute;
  left: 7px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 0.8rem;
  color: white;
  pointer-events: none;
}


.voice-icon {
  position: absolute;
  left: 7px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 0.8rem;
  color: white;
  pointer-events: none;
}


/* Flecha personalizada a la derecha */
.select-wrapper::after {
  content: "\f078"; /* Unicode de FontAwesome para flecha hacia abajo */
  font-family: "Font Awesome 6 Free";
  font-weight: 900;
  position: absolute;
  right: 5px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: white;
}

    



.english-text.size1 {
  font-size: 1.3rem;
  line-height: 2.2rem;
}
.english-text.size2 {
  font-size: 1.4rem;
  line-height: 2rem;
}
.english-text.size3 {
  font-size: 1.3rem;
  line-height: 2rem;
}





.story-card-inner {
  display: flex;
  align-items: center;
  gap: 1rem; /* espacio entre imagen y texto */
}
.story-card-image {
  flex: 0 0 auto;
  width: 100px;   /* ancho fijo para la imagen, ajustable según diseño */
  height: 100px;  /* alto fijo */
  border-radius: var(--radius-md);
  overflow: hidden;
}
.story-card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;  /* para que la imagen se ajuste sin deformarse */
}
.story-card-text {
  flex: 1;  /* ocupa el resto del espacio */
}








.carousel-container,
.carousel-container .carousel-item {
  position: relative;
  overflow: hidden !important;
  height: 240px; /* igual que tu max-height de .story-image */
}


@media screen and (min-width: 768px) {
  .carousel-container,
  .carousel-container .carousel-item {
    height: 400px !important;
  }
}


/* 2) Convierte la imagen en “cover” fullscreen dentro del contenedor */
.story-image {
  position: absolute !important;
  top: 50%; left: 50%;
  width: auto !important;
  height: auto !important;
  min-width: 100%;   /* cubre todo el ancho */
  min-height: 100%;  /* cubre toda la altura */
  object-fit: cover !important;
  transform: translate(-50%, -50%) scale(1);
  transform-origin: center center;
  animation: kenBurns 5s ease-in-out infinite alternate !important;
}

/* 3) Keyframes para zoom in–out suave */
@keyframes kenBurns {
  from { transform: translate(-50%, -50%) scale(1); }
  to   { transform: translate(-50%, -50%) scale(1.1); }
}





/* — Animaciones más rápidas y con más “punch” — */
.kb-zoom {
  animation: kenBurnsZoom 8s ease-in-out infinite alternate !important;
}
/* — Clases que aplican cada animación — */
.kb-pan-left {
  animation: kenBurnsPanLeft 8s ease-in-out infinite alternate !important;
}
.kb-pan-right {
  animation: kenBurnsPanRight 8s ease-in-out infinite alternate !important;
}
@keyframes kenBurnsZoom {
  from { transform: translate(-50%, -50%) scale(1); }
  to   { transform: translate(-50%, -50%) scale(1.2); }
}

@keyframes kenBurnsPanLeft {
  from { transform: translate(-40%, -50%) scale(1.1); }
  to   { transform: translate(-50%, -50%) scale(1);   }
}
/* — Pan desde la DERECHA: empieza escala 1.1 / 60% izquierda, acaba escala 1 / 50% centro — */
@keyframes kenBurnsPanRight {
  from { transform: translate(-40%, -50%) scale(1.1); }
  to   { transform: translate(-50%, -50%) scale(1);   }
}

    /* ============================ */
    /* Fin de la integración CSS    */
    /* ============================ */






    .controls-footer {
  position: relative;      /* necesaria para que el hijo .hand-hint se posicione respecto a este footer */
  display: flex;
  justify-content: center;
  gap: 1rem;
  padding: 1rem;
  border-top: 1px solid #3d3d3d;
}

.hand-hint {
  position: absolute;      /* lo hace “flotar” por encima de los hermanos */
  top: -70px;              /* sube el icono unos píxeles por encima del footer */
  left: 50%;               /* lo centra horizontalmente */
  transform: translateX(-50%);
  display: none;           /* lo mostraremos vía JS */
  pointer-events: none;    /* para que no interfiera con los clicks */
  animation: bounce 1s infinite;
  z-index: 10;             /* asegúrate de que esté por encima */
}

@keyframes bounce {
  0%, 100% { transform: translate(-50%, 0); }
  50%      { transform: translate(-50%, 10px); }
}




.level-label {
  display: inline-block;
  background-color: #3b82f6;    /* azul intenso */
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 600;
  margin-top: 4px;
}

/* Texto de info */
.story-info {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5db;               /* gris claro */
  line-height: 1.3;
}



.stories-filter-tabs {
  margin-top: 12px;
  display: flex;
  gap: 8px;
  display: flex;        /* activa flex layout */
  flex-wrap: wrap;      /* permite que los ítems pasen a la siguiente fila */
  gap: 0.5rem 1rem;      /* espacio entre botones (fila y columna) */
  justify-content: center; /* opcional: centra los botones */
}

.stories-filter-tabs button {
  background: transparent;
  border: none;
  font-size: 0.8rem;       /* letras pequeñas */
  color: #6b7280;           /* gris medio */
  cursor: pointer;
  padding: 4px 6px;
  border-radius: 4px;
 
  border: 2px solid #fff !important;
  color: #fff !important;
}

.stories-filter-tabs button.active {
  background-color: #134ead;  /* azul intenso */
  color: white;
}

.no-topics {
  font-style: italic;
  color: #6b7280;
  text-align: center;
  margin-top: 300px;
}









  </style>
  
  
  
</head>
<body>
  <!-- Loading Screen -->
  <div class="loading-screen">
    <div class="spinner"></div>
  </div>
  
  <!-- Stories List -->
  <section id="storiesList" class="stories-view" style="display: none;">
    <div class="stories-header">
      <h1>Interactive English Stories</h1>
      <p>Select a story to begin</p>

      <div class="stories-filter-tabs">
        <button data-level="" class="active">Todos</button>
        <button data-level="fundamental">Fundamental</button>
        <button data-level="basico">Básico</button>
        <button data-level="intermedio">Intermedio</button>
        <button data-level="avanzado">Avanzado</button>
        <button data-level="otros">Otros</button>
      </div>
      <div id="noTopicsMessage" class="no-topics" style="display: none;">
        Aún no se agregaron temas
      </div>


    </div>
    <div class="stories-grid" id="storiesContainer"></div>
  </section>
  
  <!-- Story View -->
  <main id="storyView" class="story-view" style="display: none;">
    <header class="story-header">
      <div class="header-left">
        <button id="backToStoriesButton"><i class="fas fa-arrow-left"></i></button>
        
      </div>
      <div class="header-content">
        <div class="header-title" id="storyTitle">
          Este es un título muy largo que se mostrará en varias líneas sin recorte 
        </div>


    



        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress" id="progressBar"></div>
            <span class="progress-text" id="progressText">0 de 0</span>
          </div>
        </div>

     
        
        <div class="header-right">
            <!-- Dropdown de velocidad del speech -->

            <div class="select-wrapper">
              <i class="fas fa-microphone voice-icon"></i>
              <select id="globalVoiceSelect" class="custom-select">
                <option value="m" selected>Voz hombre</option>
                <option value="w">Voz mujer</option>
              </select>
            </div>
            
            <div class="select-wrapper">
              <i class="fas fa-tachometer-alt speed-icon"></i>
              <select id="speedSelect" class="custom-select">
                <option value="0.7">Lento</option>
                <option value="0.9" selected>Normal</option>
                <option value="1.2">Rápido</option>
              </select>
            </div>
             <!-- Nuevo dropdown para elegir cantidad de sentences (size) -->
  <!-- <div class="select-wrapper">
    <i class="fas fa-text-height speed-icon"></i>
    <select id="sizeSelect" class="custom-select">
      <option value="1" selected>Tamaño 1</option>
      <option value="2">Tamaño 2</option>
      <option value="3">Tamaño 3</option>
    </select>
  </div> -->
            

          <button id="playBtn" class="play-btn">
            <i class="fas fa-gamepad"></i> Play
          </button>
          <button id="savedListBtn" class="saved-list-btn">
            <i class="fas fa-list"></i><span id="savedCount">0</span>
          </button>
        </div>
      </div>
    </header>
    <div class="story-content">
      <div class="text-cards-container" id="textCardsContainer"></div>
    </div>
    <footer class="controls-footer">

      <div id="firstTimeHint" class="hand-hint">
        <i class="fas fa-hand-point-down fa-3x"></i>
      </div>

      <button id="prevCardBtn" class="control-btn"><i class="fas fa-chevron-left"></i></button>
      <button id="mainAudioButton" class="control-btn"><i class="fas fa-play"></i></button>
      <button id="nextCardBtn" class="control-btn"><i class="fas fa-chevron-right"></i></button>
    </footer>
  </main>
  
  <!-- Game View -->
  <div id="gameView">
    <button class="exit-game" id="exitGameBtn">Salir</button>
    <div id="gameContent"></div>
  </div>
  
  <script>

const API_BASE                 = 'https://mi-worker.saturninocok.workers.dev'
const STORIES_LIST_URL         = `${API_BASE}/stories`
const STORY_DATA_URL           = id => `${API_BASE}/stories/${id}`
const STORY_TRANSLATION_URL    = id => `${API_BASE}/stories/${id}/translation`


    const PEXELS_API_KEY = 'aV5EuNmfMhHpLQYMjCOQp6YWmU6RAF5M6at5jDTRpe0pLwxk1SZzPhSC';
    
    class StoryManager {
      constructor() {
        this.stories = [];
        this.currentStory = null;
        this.currentCardIndex = 0;
        this.cards = [];
        this.speech = null;
        this.isPlaying = false;
        this.currentHighlightTimeout = null;
        this.selectedLanguage = 'en-GB';
        this.selectedSpeed = '1';
        this.savedWords = [];
        this.savedSentences = [];
        // Variables para juegos
        this.game1Index = 0;
        this.orderingAnswer = [];
        this.currentTriviaIndex = 0;
        this.triviaScore = 0;
        this.currentFillIndex = 0;
        this.fillScore = 0;
        this.currentFillData = null;
        this.memoryFirstCard = null;
        this.memoryLock = false;
        this.memoryMatches = 0;
        this.memoryTotalPairs = 0;
        this.selectedGender = 'm';

        this.audio = null;                   // HTMLAudioElement para el audio pregrabado


this.audio = null;                   // HTMLAudioElement para el audio pregrabado
    this.marks = [];                     // Array con los marks de tiempo
    this.wordTimeouts = [];   
    this.pausedTime = 0; 

        this.isSpeakingNow = false;

        this.init();
      }




      loadGlobalVoices() {
    // 1) Cargo de localStorage (si ya había selección)
    const stored = localStorage.getItem('selectedGender');
    if (stored === 'm' || stored === 'w') {
      this.selectedGender = stored;
    }

    // 2) Apunto al <select> y le pongo el valor
    const sel = document.getElementById('globalVoiceSelect');
    if (sel) {
      sel.value = this.selectedGender;

  
    }
  }

      async init() {  
    // Cargar velocidad previa
    const storedSpeed = localStorage.getItem('selectedSpeed');
   
    


    if (storedSpeed) {
    this.selectedSpeed = storedSpeed;
    // ▷ Aquí le decimos al <select> que muestre la opción guardada
    const speedEl = document.getElementById('speedSelect');
    if (speedEl) speedEl.value = this.selectedSpeed;
  }


    document.getElementById('speedSelect')
  .addEventListener('change', async e => {
    // 1) Actualiza la velocidad
    this.selectedSpeed = e.target.value;
    localStorage.setItem('selectedSpeed', this.selectedSpeed);

    // 2) Para y limpia todo lo anterior
    this.stopSpeech();  // pausa audio, limpia timeouts y quita highlights :contentReference[oaicite:0]{index=0}&#8203;:contentReference[oaicite:1]{index=1}

    // 3) Ajusta el playbackRate del audio actual
    if (this.audio) {
      this.audio.playbackRate = parseFloat(this.selectedSpeed);
    }

    // 4) Vuelve a reproducir automáticamente la tarjeta actual
    this.playCurrentCardAudio();  // arranca desde el inicio de la frase activa y reprograme los highlights :contentReference[oaicite:2]{index=2}&#8203;:contentReference[oaicite:3]{index=3}
  });

  
    // ---- AQUÍ CAMBIO ----
    await this.loadStoriesList();     // reemplaza loadStories()
    this.hideLoading();
    this.showStoriesList();
    this.setupEventListeners();
    this.loadGlobalVoices();


    document.querySelectorAll('.stories-filter-tabs button').forEach(btn => {
  btn.addEventListener('click', () => {
    // 4.1) Marcar activo
    document.querySelector('.stories-filter-tabs button.active')
      .classList.remove('active');
    btn.classList.add('active');

    // 4.2) Volver a renderizar con el nivel
    const level = btn.getAttribute('data-level');
    this.showStoriesList(level);
  });
});



  }
      
 

  async loadStoriesList() {
      console.log('🔍 [loadStoriesList] llamando a:', STORIES_LIST_URL);  // ← CORRECCIÓN

  try {
    const { data } = await axios.get(STORIES_LIST_URL);
    // Asignamos siempre el array, sin condicionar a data.success
    this.stories = data.stories || [];
    console.log('✅ [loadStoriesList] recibidas', this.stories.length, 'stories:', this.stories);
  } catch (err) {
    console.error('❌ [loadStoriesList] error:', err);
  }
}

async loadStoryDetail(id) {
  try {
    // ——— Paso 1: carga historia + traducción —————————————————————
    const [detailResp, transResp] = await Promise.all([
      axios.get(STORY_DATA_URL(id)),
      axios.get(STORY_TRANSLATION_URL(id))
    ]);
    this.currentStory = {
      ...detailResp.data.story,
      translation: transResp.data.translation
    };

    // ——— Paso 2: carpeta “folder” —————————————————————————————
    const rawTitle     = this.currentStory.title.split('<')[0].trim();
    const folder       = encodeURIComponent(rawTitle);
    this.currentFolder = folder;

    // ——— Paso 3: helper estricto para status = 200 ——————————————————
    const exists200 = async url => {
      try {
        const resp = await axios.get(url, {
          // **solo aceptamos 200**, cualquier otro status lanza
          validateStatus: status => status === 200
        });
        console.log(`✅ [EXISTS] ${url} → ${resp.status}`);
        return true;
      } catch (e) {
        // aquí cae con 404, 301, 500…
        console.warn(`❌ [MISSING] ${url}`);
        return false;
      }
    };

    // ——— Paso 4: comprueba para cada género ————————————————————————
    const genders   = ['m','w'];
    const available = [];
    for (const g of genders) {
      const base     = `data/${folder}/${g}`;
      const jsonUrl  = `${base}/marks.json`;
      const audioUrl = `${base}/speech.mp3`;

      const jsonOk  = await exists200(jsonUrl);
      const audioOk = await exists200(audioUrl);

      console.log(`→ género ${g}: marks.json? ${jsonOk}, speech.mp3? ${audioOk}`);
      if (jsonOk && audioOk) available.push(g);
    }

    // ——— Paso 5: actualiza selectedGender si ya no existe ——————————
    if (!available.includes(this.selectedGender)) {
      this.selectedGender = available[0] || 'm';
    }

    // ——— Paso 6: reconstruye el <select> SOLO con lo disponible ——————
    const sel = document.getElementById('globalVoiceSelect');
    sel.innerHTML = '';
    available.forEach(g => {
      sel.add(new Option(
        g === 'm' ? 'Voz hombre' : 'Voz mujer',
        g,
        g === this.selectedGender,
        g === this.selectedGender
      ));
    });
    // fallback: si por algún motivo no hay ninguno
    if (available.length === 0) {
      ['m','w'].forEach(g => sel.add(new Option(
        g === 'm' ? 'Voz hombre' : 'Voz mujer',
        g
      )));
      this.selectedGender = sel.value;
    }

    // ——— Paso 7: carga marks y audio definitivo ————————————————
    const g = this.selectedGender;
    const marksUrl = `data/${folder}/${g}/marks.json`;
    const audioUrl = `data/${folder}/${g}/speech.mp3`;
    this.marks = (await axios.get(marksUrl)).data;
    this.audio = new Audio(audioUrl);
    this.audio.preload      = 'auto';
    this.audio.playbackRate = parseFloat(this.selectedSpeed);

    console.log(`🎉 Cargado correctamente voz “${g}” para carpeta “${folder}”`);
  } catch (err) {
    console.error('🔥 Error en loadStoryDetail:', err);
  }
}



      
      hideLoading() { document.querySelector('.loading-screen').style.display = 'none'; }
      
      showStoriesList(filterLevel = '') {
  // 1) Referencia al contenedor y lo limpiamos
  const container = document.getElementById('storiesContainer');
  container.innerHTML = '';

  // 2) Filtramos según el nivel (si filterLevel es cadena vacía, no filtramos)
  const filtered = filterLevel
    ? this.stories.filter(s => s.level.toLowerCase() === filterLevel)
    : this.stories;

  // 3) Mostramos/u ocultamos el mensaje si no hay resultados
  const msg = document.getElementById('noTopicsMessage');
  if (filtered.length === 0) {
    msg.style.display = 'block';
  } else {
    msg.style.display = 'none';

    // 4) Recorremos solo las historias filtradas y creamos cada tarjeta
    filtered.forEach((story, index) => {
      // Extraemos título inglés y traducción española
      const eng = story.title.split('<')[0].trim();
      const spa = (story.title.split('<')[1] || '')
        .replace('>', '')
        .trim();

      // Calculamos la ruta de la imagen de portada
      const folder     = encodeURIComponent(eng);
      const localCover = `data/${folder}/img/0.jpg`;
      const fallback   = story.titleImage
        || 'https://via.placeholder.com/100?text=No+Image';

      // Creamos el elemento tarjeta
      const card = document.createElement('div');
      card.className = 'story-card';
      card.innerHTML = `
        <div class="story-card-inner">
          <div class="story-card-image">
            <img
              src="${localCover}"
              onerror="this.onerror=null;this.src='${fallback}';"
              alt="${eng}"
            >
          </div>
          <div class="story-card-text">
            <h3>${eng}</h3>
            ${spa ? `<p class="story-title-translation">${spa}</p>` : ''}
            <span class="level-label">${story.level}</span>
            <p class="story-info">${story.info}</p>
          </div>
        </div>
      `;
      // Al hacer click, abrimos la historia correspondiente
      card.addEventListener('click', () => this.showStory(index));
      container.appendChild(card);
    });
  }

  // 5) Asegurarnos de que la sección de lista esté visible
  document.getElementById('storiesList').style.display = 'block';
}




      
async showStory(storyIndex) {
  showSpinner();  
  this.currentIndex = storyIndex; 

  // ↓↓ AÑADE ESTO para limpiar cualquier estado de pausa/resume
  this.pausedTime = 0;
  this.resumeSentenceIndex = null;
  this.isPlaying = false;
  // y opcionalmente restaurar el icono a “play”
  const mainIcon = document.getElementById('mainAudioButton').querySelector('i');
  if (mainIcon) mainIcon.classList.replace('fa-pause','fa-play');

  // Cargar datos de la historia seleccionada
  await this.loadStoryDetail(storyIndex);

  // Pasar a la vista
  document.getElementById('storiesList').style.display = 'none';
  document.getElementById('storyView').style.display   = 'block';
  document.getElementById('storyTitle').textContent    =
    this.currentStory.title.split('<')[0].trim();

  // Renderizar tarjetas e imágenes
  await this.renderStoryCards();

  hideSpinner();
  this.showHint();  
}
      
      normalizeTranslationKeys() {
        const norm = {};
        for (const key in this.currentStory.translation) {
          norm[key.toLowerCase()] = this.currentStory.translation[key];
        }
        this.currentStory.translation = norm;
      }
      

      
    



      // Dentro de StoryManager
      playWordAudio(phrase) {
  if (!this.audio || !this.marks) return;
  const rate = this.audio.playbackRate || 1;
  const parts = phrase.toLowerCase().trim().split(/\s+/);

  // 1) Extraer sólo las marcas de la tarjeta actual
  const card = this.cards[this.currentCardIndex];
  const startIdx = parseInt(card.dataset.markStart, 10);
  const endIdx = this.cards[this.currentCardIndex + 1]
    ? parseInt(this.cards[this.currentCardIndex + 1].dataset.markStart, 10)
    : this.marks.length;
  const slice = this.marks.slice(startIdx, endIdx);

  // 2) Para cada palabra del phrase, escoger la aparición en slice que venga después de la anterior
  const found = [];
  let lastTime = -Infinity;
  for (const part of parts) {
    // Todas las ocurrencias de “part” en este slice, ordenadas por start
    const matches = slice
      .filter(m => m.word.toLowerCase() === part)
      .sort((a, b) => a.start - b.start);
    // Elegir la primera cuyo start > lastTime
    const pick = matches.find(m => m.start > lastTime);
    if (!pick) {
      console.warn(`❌ No se encontró "${part}" tras ${lastTime}s dentro de la tarjeta.`);
      return;
    }
    found.push(pick);
    lastTime = pick.start;
  }

  // 3) Calcular inicio y fin (restando pequeño offset según velocidad)
  const startTime = found[0].start;
  const rawEnd   = found[found.length - 1].end;
  let offset;
  if (rate < 1)        offset = 0.0;
  else if (rate === 1) offset = 0.0;
  else                 offset = 0.0;
  const endTime = Math.max(startTime, rawEnd - offset);
  const durationMs = ((endTime - startTime) * 1000) / rate + 50;

  // 4) Reproducir fragmento
  clearTimeout(this._wordTimeout);
  this.audio.pause();
  this.audio.currentTime = startTime;
  this.audio.play();
  this._wordTimeout = setTimeout(() => this.audio.pause(), durationMs);

  console.log(`🎧 "${phrase}" desde ${startTime.toFixed(3)}s hasta ${endTime.toFixed(3)}s`);
}


// Actualiza el tamaño de fuente de los elementos .english-text según el valor global this.selectedSize.
updateEnglishTextFontSize() {
  const englishElements = document.querySelectorAll('.text-card .english-text');
  englishElements.forEach(el => {
    el.classList.remove('size1', 'size2', 'size3');
    if (this.selectedSize === "1") {
      el.classList.add('size1'); // font-size: 1.8rem
    } else if (this.selectedSize === "2") {
      el.classList.add('size2'); // font-size: 1.3rem
    } else if (this.selectedSize === "3") {
      el.classList.add('size3'); // font-size: 0.8rem
    }
  });
}

// Inicializa el carrusel para un contenedor dado.
initializeCarousel(carousel) {
  if (!carousel) return;
  let currentIndex = 0;
  const items = carousel.querySelectorAll('.carousel-item');
  const totalItems = items.length;
  if (totalItems === 0) return;
  
  const showItem = index => {
    items.forEach((item, i) => {
      if (i === index) item.classList.add('active');
      else item.classList.remove('active');
    });
  };
  
  // Auto-slider: cambia de imagen cada 5 segundos.
  let interval = setInterval(() => {
    currentIndex = (currentIndex + 1) % totalItems;
    showItem(currentIndex);
  }, 5000);
  
  // Botones manuales.
  const btnPrev = carousel.querySelector('.carousel-control.prev');
  const btnNext = carousel.querySelector('.carousel-control.next');
  if (btnPrev) {
    btnPrev.addEventListener('click', () => {
      clearInterval(interval);
      currentIndex = (currentIndex - 1 + totalItems) % totalItems;
      showItem(currentIndex);
      // Reinicia el intervalo.
      interval = setInterval(() => {
        currentIndex = (currentIndex + 1) % totalItems;
        showItem(currentIndex);
      }, 5000);
    });
  }
  if (btnNext) {
    btnNext.addEventListener('click', () => {
      clearInterval(interval);
      currentIndex = (currentIndex + 1) % totalItems;
      showItem(currentIndex);
      // Reinicia el intervalo.
      interval = setInterval(() => {
        currentIndex = (currentIndex + 1) % totalItems;
        showItem(currentIndex);
      }, 5000);
    });
  }
}

// Método que carga las imágenes de Pexels para cada imagen en el carrusel.
loadStoryImages() {
  document.querySelectorAll('.carousel-container img').forEach(img => {
    const query = img.getAttribute('data-image-query');
    // Si ya se cargó una URL en src (porque textObj.image era una URL), no hace nada.
    if (img.getAttribute('src') && (img.getAttribute('src').startsWith("http://") || img.getAttribute('src').startsWith("https://"))) {
      return;
    }
    if (query) {
      // Si el valor del query es en sí mismo una URL, se carga directamente.
      if (/^https?:\/\//i.test(query)) {
        img.src = query;
      } else {
        axios.get(`https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=1`,
          { headers: { Authorization: PEXELS_API_KEY } })
        .then(response => {
          if (response.data.photos && response.data.photos.length > 0) {
            const photo = response.data.photos[0];
            img.src = photo.src.medium;
          } else {
            img.src = `https://via.placeholder.com/600x250?text=${encodeURIComponent(query)}`;
          }
        })
        .catch(error => {
          console.error('Error loading image for', query, error);
          img.src = `https://via.placeholder.com/600x250?text=${encodeURIComponent(query)}`;
        });
      }
    }
  });
}

// Método que renderiza las tarjetas de la historia.
async renderStoryCards() {
  const container = document.getElementById('textCardsContainer');
  container.innerHTML = '';
  this.cards = [];
  this.currentCardIndex = 0;

  // 1) Preparo las marcas para cada textObj
  const marksCopy = [...this.marks];
  this.currentStory.text.forEach(textObj => {
    const cleanWords = textObj.english
      .replace(/[.,¿?!'"“”‘’()]/g, '')
      .replace(/\s+/g, ' ')
      .trim()
      .split(' ');
    textObj.marks = marksCopy.splice(0, cleanWords.length);
  });

  // 2) Agrupo según el tamaño de tarjetas
  const groupSize = parseInt(this.selectedSize, 10) || 1;
  const grouped = [];
  for (let i = 0; i < this.currentStory.text.length; i += groupSize) {
    grouped.push(this.currentStory.text.slice(i, i + groupSize));
  }

  let globalIdx = 0;
  let paragraphIndex = 0;
  const folder = this.currentFolder;

  // 3) Construyo cada tarjeta
  for (const group of grouped) {
    let engHTML = '';
    let spaHTML = '';
    let imgsHTML = '';
    let imgCount = 0;
    const vocabMap = {};
    const vocabSet = new Set();

    // 3.1) Cobro texto, imágenes y vocabulario
    group.forEach(obj => {
      engHTML += `<div>${this.addWordSpans(obj.english, obj.phrasal_verbs, obj.vocabulary)}</div>`;
      spaHTML += `<div>${obj.spanish}</div>`;

      // imagen local numerada
      paragraphIndex++;
      const localPath = `data/${folder}/img/${paragraphIndex}.jpg`;
      const isURL = /^https?:\/\//i.test(obj.image);
      imgsHTML += `
        <div class="carousel-item ${imgCount === 0 ? 'active' : ''}">
          <img
            src="${localPath}"
            class="story-image"
            loading="lazy"
            onerror="this.onerror=null;${isURL
              ? `this.src='${obj.image}';`
              : `this.removeAttribute('src');this.setAttribute('data-image-query','${obj.image}');`}"
          >
        </div>`;
      imgCount++;

      // vocabulario & phrasal verbs
      if (obj.vocabulary) {
        Object.entries(obj.vocabulary).forEach(([w, t]) => {
          vocabMap[w.toLowerCase()] = t;
          vocabSet.add(w.toLowerCase());
        });
      }
      if (obj.phrasal_verbs) {
        Object.entries(obj.phrasal_verbs).forEach(([pv, t]) => {
          vocabMap[pv.toLowerCase()] = t;
          vocabSet.add(pv.toLowerCase());
        });
      }
    });

    // 3.2) HTML del carrusel
    const carouselHTML = imgCount > 0
      ? `<div class="carousel-container">
           <div class="carousel-inner">${imgsHTML}</div>
           <button class="carousel-control prev"><i class="fas fa-chevron-left"></i></button>
           <button class="carousel-control next"><i class="fas fa-chevron-right"></i></button>
         </div>`
      : '';

    // 3.3) HTML de vocabulario
    const vocabHTML = vocabSet.size > 0
      ? `<div class="vocabulary-container">
           <p class="vocabulary-title">Vocabulary:</p>
           <button class="vocab-carousel-control left"><i class="fas fa-chevron-left"></i></button>
           <div class="vocabulary-words">
             ${[...vocabSet].map(w => `
               <div class="vocabulary-word" data-word="${w}" data-translation="${vocabMap[w]}">
                 <div class="vocabulary-image"><img src="" alt="${w}" loading="lazy"></div>
                 <div class="vocabulary-text"><strong>${w}</strong><span class="vocabulary-translation">${vocabMap[w]}</span></div>
               </div>
             `).join('')}
           </div>
           <button class="vocab-carousel-control right"><i class="fas fa-chevron-right"></i></button>
         </div>`
      : '';

    // 3.4) Creo el elemento card
    const card = document.createElement('div');
    card.className = 'text-card';
    card.innerHTML = `
      ${carouselHTML}
      <div class="sentence-container">
        <div class="english-text">${engHTML}</div>
        <div class="full-translation">${spaHTML}</div>
        <div class="toggle-container">
          <button class="toggle-sentence-add btn-professional"><i class="fas fa-plus"></i> A lista</button>
          <button class="toggle-word-translation btn-professional"><i class="fas fa-language"></i> Traducir Palabras</button>
        </div>
        ${vocabHTML}
      </div>`;

// 3.5) Marcas de tiempo
card.dataset.markStart = globalIdx;

// Cuenta cuántos spans de palabras hay en esta tarjeta
const sentenceDivs = Array.from(card.querySelectorAll('.english-text > div'));
const wordsCount = sentenceDivs
  .map(div =>
    Array.from(div.querySelectorAll(
      '.highlight-word, .phrasal-verb-inline, .vocabulary-inline'
    )).length
  )
  .reduce((a, b) => a + b, 0);

globalIdx += wordsCount;

    // 4) Inserto en DOM y guardo referencia
    container.appendChild(card);
    this.cards.push(card);

    // 5) Eventos de toggles
    const btnTranslate = card.querySelector('.toggle-word-translation');
    btnTranslate.addEventListener('click', () => {
      card.classList.toggle('show-translations');
      btnTranslate.innerHTML = card.classList.contains('show-translations')
        ? '<i class="fas fa-language"></i> Ocultar Traducciones'
        : '<i class="fas fa-language"></i> Traducir Palabras';
    });
    const btnAdd = card.querySelector('.toggle-sentence-add');
    btnAdd.addEventListener('click', () => {
      const sent = card.querySelector('.english-text').innerText.trim();
      const trans = card.querySelector('.full-translation').innerText.trim();
      if (!this.savedSentences.some(x => x.sentence === sent)) {
        this.savedSentences.push({ sentence: sent, translation: trans });
      }
      document.getElementById('savedCount').textContent = this.savedSentences.length + this.savedWords.length;
      alert('Oración agregada a la lista.');
    });

    // 6) Inicializo carrusel si existe
    if (carouselHTML) {
      const carousel = card.querySelector('.carousel-container');
      this.initializeCarousel(carousel);
    }
  }

  // 7) Arranco la vista
  this.showCard(0);
  this.setupWordInteractions();
  this.loadVocabularyImages();
  this.loadStoryImages();
  this.updateEnglishTextFontSize();
  this.setupVocabularyCarousel();
}





showHint() {
  if (localStorage.getItem('hasSeenPlayHint')) return;
  const hint = document.getElementById('firstTimeHint');
  hint.style.display = 'block';
  setTimeout(() => hint.style.display = 'none', 3000);
  document.getElementById('mainAudioButton')
    .addEventListener('click', () => {
      hint.style.display = 'none';
      localStorage.setItem('hasSeenPlayHint', 'true');
    }, { once: true });
}


setupVocabularyCarousel() {
  document.querySelectorAll('.vocabulary-container').forEach(container => {
    const vocabWords = container.querySelector('.vocabulary-words');
    // Botones de control para scroll manual
    const leftBtn = container.querySelector('.vocab-carousel-control.left');
    const rightBtn = container.querySelector('.vocab-carousel-control.right');

    const images = vocabWords.querySelectorAll('img');
    let loadedCount = 0;
    let autoScrollInterval; // Variable para almacenar el intervalo del auto-scroll

    // Función que comprueba si se han cargado todas las imágenes y, en ese caso, inicia el auto-scroll.
    const maybeStart = () => {
      if (loadedCount === images.length) {
        startAutoScroll();
      }
    };

    // Verifica la carga de cada imagen y cuenta cuántas ya están cargadas.
    images.forEach(img => {
      if (img.complete) {
        loadedCount++;
      } else {
        img.addEventListener('load', () => {
          loadedCount++;
          maybeStart();
        });
      }
    });
    // Si todas ya están cargadas desde el inicio.
    maybeStart();

    // Listener para detener el auto-scroll si se hace click en el contenedor (o en alguno de sus descendientes)
    container.addEventListener('click', (e) => {
      if (autoScrollInterval) {
        clearInterval(autoScrollInterval);
        autoScrollInterval = null;
        console.log("Auto-scroll detenido por click en el contenedor");
      }
    }, true); // fase de captura, para detectar antes que otros handlers

    // Listener específico para cada vocabulary-word
    vocabWords.querySelectorAll('.vocabulary-word').forEach(wordElem => {
      wordElem.addEventListener('click', (e) => {
        if (autoScrollInterval) {
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
          console.log("Auto-scroll detenido por click en un vocabulary-word");
        }
      });
    });

    // Listener para el botón izquierdo
    if (leftBtn) {
      leftBtn.addEventListener('click', (e) => {
        if (autoScrollInterval) {
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
        }
        // Ajusta el valor de desplazamiento (por ejemplo, -100 px) según tus necesidades
        vocabWords.scrollBy({ left: -100, behavior: 'smooth' });
      });
    }

    // Listener para el botón derecho
    if (rightBtn) {
      rightBtn.addEventListener('click', (e) => {
        if (autoScrollInterval) {
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
        }
        // Desplaza 100 px a la derecha, por ejemplo
        vocabWords.scrollBy({ left: 100, behavior: 'smooth' });
      });
    }

    // Función que inicia el auto-scroll.
    function startAutoScroll() {
      const checkBoundaries = () => {
        const buffer = 10;
        const left = vocabWords.scrollLeft;
        const client = vocabWords.clientWidth;
        const scroll = vocabWords.scrollWidth;
        const atStart = left <= buffer;
        const atEnd = left + client >= scroll - buffer;
        
        return { atStart, atEnd };
      };

      autoScrollInterval = setInterval(() => {
        const { atEnd } = checkBoundaries();
        if (atEnd) {
          // Si se alcanza el final, detener el auto-scroll.
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
          console.log("Se detiene el auto-scroll al llegar al final");
        } else {
          vocabWords.scrollBy({ left: 1, behavior: 'auto' });
        }
      }, 30);
    }
  });
}






      getVocabularyForSentence(sentence, vocabList) {
        if (!vocabList) return [];
        const lowerSentence = sentence.toLowerCase();
        let detected = [];
        vocabList.forEach(phrase => {
          if (lowerSentence.includes(phrase)) {
            detected.push(phrase);
          }
        });
        return [...new Set(detected)];
      }
      
      addWordSpans(sentence, phrasalVerbs = {}, vocabObj = {}) {
  const words = sentence.split(/\s+/);
  let result = '';

  for (let i = 0; i < words.length; i++) {
    const raw = words[i];
    // limpio comillas, paréntesis y puntuación final
    const clean = raw.replace(/[.,¿?!'"“”‘’()]/g, '').toLowerCase();

    // 1) Caso especial sufijo ’s o 's:
    const apostropheMatch = raw.match(/^(.*?)([’']s)$/);
    if (apostropheMatch) {
      const [ , baseRaw, suffixRaw ] = apostropheMatch;
      const cleanBase = baseRaw.toLowerCase();
      const cleanSuffix = suffixRaw.toLowerCase();

      // Span para la parte base con posible tooltip
      const baseTooltip = vocabObj[cleanBase] || '';
      const baseClasses = 'highlight-word' + (baseTooltip ? ' vocabulary-inline' : '');
      result += `<span class="${baseClasses}" data-word="${cleanBase}"` +
                (baseTooltip ? ` data-translation="${baseTooltip}"` : '') +
                `>${baseRaw}` +
                (baseTooltip
                  ? `<span class="translation-tooltip">${baseTooltip}</span>`
                  : ''
                ) +
                `</span> `;

      // Span para el sufijo
      result += `<span class="highlight-word" data-word="${cleanSuffix}">${suffixRaw}</span> `;
      continue;
    }


    // 1a) Caso especial sufijo ’t o 't:
const apostropheTMatch = raw.match(/^(.*?)([’']t)$/);
if (apostropheTMatch) {
  const [ , baseRawT, suffixRawT ] = apostropheTMatch;
  const cleanBaseT  = baseRawT.toLowerCase();
  const cleanSuffixT = suffixRawT.toLowerCase();

  // Span para la parte base con posible tooltip
  const baseTooltipT = vocabObj[cleanBaseT] || '';
  const baseClassesT = 'highlight-word' + (baseTooltipT ? ' vocabulary-inline' : '');
  result += `<span class="${baseClassesT}" data-word="${cleanBaseT}"` +
            (baseTooltipT ? ` data-translation="${baseTooltipT}"` : '') +
            `>${baseRawT}` +
            (baseTooltipT
              ? `<span class="translation-tooltip">${baseTooltipT}</span>`
              : ''
            ) +
            `</span> `;

  // Span para el sufijo ’t/'t
  result += `<span class="highlight-word" data-word="${cleanSuffixT}">${suffixRawT}</span> `;
  continue;
}





    // 2) Phrasal verbs de dos palabras
    if (phrasalVerbs && i < words.length - 1) {
      const nextRaw = words[i + 1];
      const cleanNext = nextRaw.replace(/[.,¿?!'"“”‘’()]/g, '').toLowerCase();
      const two = `${clean} ${cleanNext}`;
      if (phrasalVerbs[two]) {
        const tooltip = phrasalVerbs[two];
        // Dos spans separados, cada uno resaltable
        result +=
          `<span class="highlight-word vocabulary-inline" data-word="${clean}" data-translation="${tooltip}">` +
            `${raw}<span class="translation-tooltip">${tooltip}</span>` +
          `</span> ` +
          `<span class="highlight-word vocabulary-inline" data-word="${cleanNext}" data-translation="${tooltip}">` +
            `${nextRaw}<span class="translation-tooltip">${tooltip}</span>` +
          `</span> `;
        i++;
        continue;
      }
    }

    // 3) Palabra normal o vocabulario
    let tooltip = '';
    let classes = 'highlight-word';
    if (vocabObj[clean]) {
      tooltip = vocabObj[clean];
      classes += ' vocabulary-inline';
    }

    result += `<span class="${classes}" data-word="${clean}"` +
              (tooltip ? ` data-translation="${tooltip}"` : '') +
              `>${raw}` +
              (tooltip
                ? `<span class="translation-tooltip">${tooltip}</span>`
                : ''
              ) +
              `</span> `;
  }

  return result.trim();
}

      
showCard(index) {
  // 1) Detener cualquier audio en curso
  if (this._wordTimeout) clearTimeout(this._wordTimeout);
  this.audio?.pause();

  // 2) Ocultar la tarjeta anterior
  const prev = this.cards[this.currentCardIndex];
  if (prev) prev.classList.remove('active');

  // 3) Actualizar índice y mostrar nueva tarjeta
  this.currentCardIndex = index;
  const card = this.cards[index];
  card.classList.add('active');

  // 4) Actualizar barra de progreso y texto
  const total  = this.cards.length;
  const current = index + 1;
  const pct     = (current / total) * 100;
  document.getElementById('progressBar').style.width  = `${pct}%`;
  document.getElementById('progressText').textContent = `${current} de ${total}`;

  // 5) Aplicar animación Ken Burns aleatoria a la imagen
  const img = card.querySelector('.story-image');
  if (img) {
    img.classList.remove('kb-zoom', 'kb-pan-left', 'kb-pan-right');
    const effects = ['kb-zoom', 'kb-pan-left', 'kb-pan-right'];
    img.classList.add(effects[Math.floor(Math.random() * effects.length)]);
  }

  // 6) Ajustar tamaño de fuente según preferencia
  this.updateEnglishTextFontSize();

  // 7) (Re)activar interacciones de palabras
  this.setupWordInteractions();
}




      updateProgress() {
  const total = this.cards.length;
  const current = this.currentCardIndex + 1;
  const progressPercentage = (current / total) * 100;
  document.getElementById('progressBar').style.width = progressPercentage + '%';
  document.getElementById('progressText').textContent = `${current} de ${total}`;
}
      
setupWordInteractions() { 
  // 1) Si había un handler previo, lo quitamos de la card anterior
  if (this._cardClickHandler && this._prevCard) {
    this._prevCard.removeEventListener('click', this._cardClickHandler);
  }

  // 2) Creamos un handler que escuche TODO click en la card
  const card = this.cards[this.currentCardIndex];
  const handler = e => {
    // Buscamos el elemento clicado más cercano que sea palabra o vocab
    const wordElem = e.target.closest(
      '.highlight-word, .phrasal-verb-inline, .vocabulary-inline, .vocabulary-word'
    );
    if (!wordElem || !card.contains(wordElem)) return;

    e.stopPropagation();
    this.showWordPopup(wordElem);
  };

  // 3) Lo enganchamos a la card
  card.addEventListener('click', handler);

  // 4) Almacenamos referencias para poder limpiarlo la próxima vez
  this._cardClickHandler = handler;
  this._prevCard = card;
}


speakText(textToSpeak) {
  if (!textToSpeak) return;

  // Esperar hasta que speechSynthesis esté completamente inactivo
  const waitUntilFree = () => {
    if (!speechSynthesis.speaking && !speechSynthesis.pending) {
      const utterance = new SpeechSynthesisUtterance(textToSpeak);

      if (this.selectedVoice) {
        utterance.voice = this.selectedVoice;
      } else {
        utterance.lang = 'en-US';
      }

      utterance.rate = parseFloat(this.selectedSpeed) || 1;

      this.isSpeakingNow = true;

      utterance.addEventListener('end', () => {
        this.isSpeakingNow = false;
      });

      utterance.addEventListener('error', () => {
        this.isSpeakingNow = false;
      });

      console.log("✅ Hablando (espera activa):", textToSpeak, "con voz:", utterance.voice?.name || utterance.lang);
      speechSynthesis.speak(utterance);
    } else {
      // Esperar un poco más si aún está hablando
      console.log("⏳ Esperando a que termine el audio anterior...");
      setTimeout(waitUntilFree, 100);
    }
  };

  waitUntilFree(); // iniciar espera inteligente
}



showWordPopup(wordElement) {
  // Remover cualquier popup existente
  const existingPopup = document.querySelector('.word-popup');
  if (existingPopup) { existingPopup.remove(); }

  // Obtener palabra y traducción
  const word = wordElement.getAttribute('data-word') || wordElement.textContent.trim();
  const translation = wordElement.getAttribute('data-translation') || "";

  // Crear popup
  const popup = document.createElement('div');
  popup.className = 'word-popup';
  popup.innerHTML = `
    <div class="popup-content">
      <h2>${word}</h2>
      <p>${translation}</p>
      <div class="popup-image"></div>
      <button class="popup-close btn-professional">OK</button>
      <button class="popup-add btn-professional">Agregar</button>
    </div>
  `;
  document.body.appendChild(popup);


   // Obtenemos el texto de la palabra y reproducimos su fragmento
   const wordText = wordElement.getAttribute('data-word') || wordElement.textContent.trim();
  this.playWordAudio(wordText);

  // Opcional: si quieres detener el audio al cerrar el popup:
  popup.querySelector('.popup-close').addEventListener('click', () => {
    if (this._wordTimeout) clearTimeout(this._wordTimeout);
    this.audio.pause();
    popup.remove();
  });


  // Cancelar cualquier speech en curso
  window.speechSynthesis.cancel();

  // Si se estaba reproduciendo el audio principal, cancelarlo y actualizar el ícono
  if (this.isPlaying) {
    this.isPlaying = false;
    const mainBtnIcon = document.getElementById("mainAudioButton").querySelector("i");
    if (mainBtnIcon && mainBtnIcon.classList.contains("fa-pause")) {
      mainBtnIcon.classList.replace("fa-pause", "fa-play");
    }
  }

  // ✅ Reproducir la palabra con voz seleccionada o en-US por defecto
  //this.speakText(word);

  // Obtener la imagen correspondiente a la palabra desde Pexels
  axios.get(`https://api.pexels.com/v1/search?query=${encodeURIComponent(word)}&per_page=1`, {
    headers: { Authorization: PEXELS_API_KEY }
  })
  .then(response => {
    const imgDiv = popup.querySelector('.popup-image');
    if (response.data.photos && response.data.photos.length > 0) {
      const photo = response.data.photos[0];
      imgDiv.innerHTML = `<img src="${photo.src.small}" alt="${word}">`;
    } else {
      imgDiv.innerHTML = `<img src="https://via.placeholder.com/150?text=${encodeURIComponent(word)}" alt="${word}">`;
    }
  })
  .catch(error => {
    console.error("Error fetching image for word:", error);
    const imgDiv = popup.querySelector('.popup-image');
    imgDiv.innerHTML = `<img src="https://via.placeholder.com/150?text=${encodeURIComponent(word)}" alt="${word}">`;
  });

  // Listener para cerrar el popup
  popup.querySelector('.popup-close').addEventListener('click', (e) => {
    e.stopPropagation();
    popup.remove();
  }, { once: true });

  // Listener para agregar palabra a la lista
  popup.querySelector('.popup-add').addEventListener('click', (e) => {
    e.stopPropagation();
    if (!this.savedWords.some(item => item.word === word)) {
      this.savedWords.push({ word, translation });
      document.getElementById('savedCount').textContent = this.savedSentences.length + this.savedWords.length;
    }
    popup.remove();
  }, { once: true });

  // Prevenir propagación del click
  popup.addEventListener('click', (e) => e.stopPropagation());
}






      showSavedListPopup() {
        const existingPopup = document.querySelector('.saved-list-popup');
        if (existingPopup) { existingPopup.remove(); }
        const popup = document.createElement('div');
        popup.className = 'saved-list-popup';
        let sentencesHTML = '';
        if (this.savedSentences.length > 0) {
          sentencesHTML = '<h3>Oraciones Guardadas</h3><ul>';
          this.savedSentences.forEach((item, index) => {
            sentencesHTML += `<li>
                                <span>${item.sentence} - ${item.translation}</span>
                                <button data-index="${index}" class="delete-sentence-btn btn-professional">Eliminar</button>
                              </li>`;
          });
          sentencesHTML += '</ul>';
        } else {
          sentencesHTML = '<p>No hay oraciones guardadas.</p>';
        }
        let vocabularyHTML = '';
        if (this.savedWords.length > 0) {
          vocabularyHTML = '<h3>Vocabulary Guardado</h3><ul>';
          this.savedWords.forEach((item, index) => {
            vocabularyHTML += `<li>
                                <span>${item.word} - ${item.translation}</span>
                                <button data-index="${index}" class="delete-word-btn btn-professional">Eliminar</button>
                              </li>`;
          });
          vocabularyHTML += '</ul>';
        } else {
          vocabularyHTML = '<p>No hay palabras guardadas.</p>';
        }
        popup.innerHTML = `
          <h2>Guardado</h2>
          ${sentencesHTML}
          ${vocabularyHTML}
          <div class="popup-buttons">
            <button class="popup-play-btn btn-professional">Practicar y Jugar</button>
            <button class="popup-close btn-professional">Cerrar</button>
          </div>
        `;
        document.body.appendChild(popup);
        popup.querySelectorAll('.delete-sentence-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const idx = parseInt(e.currentTarget.getAttribute('data-index'));
            this.savedSentences.splice(idx, 1);
            popup.remove();
            this.showSavedListPopup();
          });
        });
        popup.querySelectorAll('.delete-word-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const idx = parseInt(e.currentTarget.getAttribute('data-index'));
            this.savedWords.splice(idx, 1);
            document.getElementById('savedCount').textContent = this.savedSentences.length + this.savedWords.length;
            popup.remove();
            this.showSavedListPopup();
          });
        });
        popup.querySelector('.popup-close').addEventListener('click', (e) => {
          e.stopPropagation();
          popup.remove();
        }, { once: true });
        popup.querySelector('.popup-play-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          alert("Modo Practicar y Jugar activado");
        });
        popup.addEventListener('click', (e) => e.stopPropagation());
      }
      

      playCurrentCardAudio() {
  // limpia cualquier estado previo
  this.stopSpeech();

  const card = this.cards[this.currentCardIndex];
  const sentenceDivs = Array.from(card.querySelectorAll('.english-text > div'));
  const sentencesWords = sentenceDivs.map(div =>
    Array.from(div.querySelectorAll('.highlight-word, .phrasal-verb-inline, .vocabulary-inline'))
  );

  const markStartGlobal = parseInt(card.dataset.markStart, 10) || 0;
  let localIdx = 0;
  const sentenceMarks = sentencesWords.map(nodes => {
    const slice = this.marks.slice(markStartGlobal + localIdx, markStartGlobal + localIdx + nodes.length);
    localIdx += nodes.length;
    return slice;
  });

  const rate = parseFloat(this.selectedSpeed) || 1;
  this.audio.playbackRate = rate;

  const playSentence = (i) => {
    // ← SI YA NO HAY MÁS FRASES
    if (i >= sentenceMarks.length) {
      // ← AÑADIDO: reset completa de pausa para que próximo Play reinicie la frase
      this.pausedTime = 0;
      this.resumeSentenceIndex = null;
      this.isPlaying = false;
      const iconEnd = document.getElementById('mainAudioButton').querySelector('i');
      if (iconEnd) iconEnd.classList.replace('fa-pause','fa-play');
      return;
    }

    const marksForSentence = sentenceMarks[i];
    if (!marksForSentence.length) return playSentence(i+1);

    const startTime = marksForSentence[0].start;
    const endTime   = marksForSentence[marksForSentence.length - 1].end;

    const actualStart = (this.resumeSentenceIndex === i)
      ? this.pausedTime
      : startTime;

    this.audio.currentTime = actualStart;
    this.audio.play();
    this.isPlaying = true;
    document.getElementById('mainAudioButton').querySelector('i')
      .classList.replace('fa-play','fa-pause');

    marksForSentence.forEach((m, idx) => {
      const highlightDelay = Math.max(0, (m.start - actualStart) / rate * 1000);
      const unhighlightDelay = Math.max(0, (m.end   - actualStart) / rate * 1000);

      if (this.resumeSentenceIndex===i && m.end <= this.pausedTime) return;

      const hTO = setTimeout(() => sentencesWords[i][idx].classList.add('active'), highlightDelay);
      const uTO = setTimeout(() => sentencesWords[i][idx].classList.remove('active'), unhighlightDelay);
      this.wordTimeouts.push(hTO, uTO);
    });

    const phraseEndDelay = (endTime - actualStart) / rate * 1000;
    const endTO = setTimeout(() => {
      this.audio.pause();
      this.wordTimeouts.forEach(t => clearTimeout(t));
      this.wordTimeouts = [];
      sentencesWords[i].forEach(n => n.classList.remove('active'));
      playSentence(i+1);
    }, phraseEndDelay);

    this.wordTimeouts.push(endTO);
  };

  if (this.pausedTime) {
    const idx = sentenceMarks.findIndex(marks => {
      if (!marks.length) return false;
      const s = marks[0].start, e = marks[marks.length-1].end;
      return this.pausedTime >= s && this.pausedTime <= e;
    });
    this.resumeSentenceIndex = idx >= 0 ? idx : 0;
    playSentence(this.resumeSentenceIndex);
  } else {
    this.resumeSentenceIndex = null;
    playSentence(0);
  }
}






// Función que actualiza el tamaño de los elementos .english-text
updateEnglishTextFontSize() {
  // Busca todos los contenedores de texto en las tarjetas (ya renderizadas)
  const englishElements = document.querySelectorAll('.text-card .english-text');
  englishElements.forEach(el => {
    el.classList.remove('size1', 'size2', 'size3');
    if (this.selectedSize === "1") {
      el.classList.add('size1'); // font-size: 1.8rem
    } else if (this.selectedSize === "2") {
      el.classList.add('size2'); // font-size: 1.3rem
    } else if (this.selectedSize === "3") {
      el.classList.add('size3'); // font-size: 0.8rem
    }
  });
}



calculateExactWordDurations(text, voiceURI, rate) {
  const avgCharsPerSecond = 15;
  const words = text.split(' ');
  return words.map(word => {
    const wordLength = word.replace(/[^a-zA-Z]/g, '').length;
    const duration = (wordLength / avgCharsPerSecond) * 1000;
    return duration / rate;
  });
}













      showFullTranslation() {
        // Lógica adicional si se desea
      }
      
      stopSpeech() {
  if (this.audio && !this.audio.paused) {
    this.pausedTime = this.audio.currentTime;
  }
  // limpiamos audio
  if (this.audio) this.audio.pause();

  this.wordTimeouts.forEach(to => clearTimeout(to));
  this.wordTimeouts = [];

  const activeSel = this.cards[this.currentCardIndex]
    .querySelectorAll('.highlight-word.active, .phrasal-verb-inline.active, .vocabulary-inline.active');
  activeSel.forEach(n => n.classList.remove('active'));

  this.isPlaying = false;
  const icon = document.getElementById('mainAudioButton').querySelector('i');
  if (icon) icon.classList.replace('fa-pause','fa-play');
}


resumeSpeech() {
  if (!this.audio) return;
  this.isPlaying = true;
  const icon = document.getElementById('mainAudioButton').querySelector('i');
  if (icon) icon.classList.replace('fa-play','fa-pause');
  // No limpiar pausedTime ni resumeSentenceIndex
  this.playCurrentCardAudio();
}

setupEventListeners() {
  // Botón principal de play/pause/resume
  const mainBtn = document.getElementById('mainAudioButton');
  mainBtn.addEventListener('click', () => {
    if (this.isPlaying) {
      this.stopSpeech();
    } else if (this.audio && this.audio.currentTime > 0 && this.audio.currentTime < this.audio.duration) {
      this.resumeSpeech();
    } else {
      this.playCurrentCardAudio();
    }
  });

  // Anterior: resetea estado de pausa y arranca desde el inicio de la tarjeta previa
  document.getElementById('prevCardBtn').addEventListener('click', () => {
    if (this.currentCardIndex > 0) {
      // 1) Detenemos y limpiamos TODO
      this.stopSpeech();
      // 2) Ahora sí reseteamos la posición de pausa
      this.pausedTime = 0;
      this.resumeSentenceIndex = null;
      // 3) Cambiamos de tarjeta y arrancamos desde el primer mark
      this.showCard(this.currentCardIndex - 1);
      this.playCurrentCardAudio();
    }
    setTimeout(() => this.setupVocabularyCarousel(), 200);
  });

  // Siguiente: resetea estado de pausa y arranca desde el inicio de la tarjeta siguiente
  document.getElementById('nextCardBtn').addEventListener('click', () => {
    if (this.currentCardIndex < this.cards.length - 1) {
      this.stopSpeech();
      this.pausedTime = 0;
      this.resumeSentenceIndex = null;
      this.showCard(this.currentCardIndex + 1);
      this.playCurrentCardAudio();
    }
    setTimeout(() => this.setupVocabularyCarousel(), 200);
  });

  // Volver a la lista de historias
  document.getElementById('backToStoriesButton').addEventListener('click', () => {
    this.stopSpeech();
    document.getElementById('storyView').style.display = 'none';
    document.getElementById('storiesList').style.display = 'block';
  });

  // Ver lista guardada
  document.getElementById('savedListBtn').addEventListener('click', () => {
    this.showSavedListPopup();
  });

  // Iniciar juego
  document.getElementById('playBtn').addEventListener('click', () => {
    this.showGameSelectionPopup();
  });

  // Salir de juego
  document.getElementById('exitGameBtn').addEventListener('click', () => {
    this.exitGame();
  });

  // Cambio de voz global
  document.getElementById('globalVoiceSelect').addEventListener('change', async e => {
    this.selectedGender = e.target.value;
    localStorage.setItem('selectedGender', this.selectedGender);
    if (this.currentIndex == null) return;
    this.stopSpeech();
    await this.loadStoryDetail(this.currentIndex);
    this.playCurrentCardAudio();
  });

  // Ajuste de tamaño de fuente al redimensionar ventana (para memory game)
  window.addEventListener('resize', () => {
    if (document.getElementById('game3Container')) {
      this.resizeMemoryCardsGrid();
    }
  });
}


      
      
      loadVocabularyImages() {
        document.querySelectorAll('.vocabulary-image img').forEach(el => {
          const word = el.getAttribute('alt').trim();
          axios.get(`https://api.pexels.com/v1/search?query=${encodeURIComponent(word)}&per_page=1`, { headers: { Authorization: PEXELS_API_KEY } })
            .then(response => {
              if(response.data.photos && response.data.photos.length > 0) {
                const photo = response.data.photos[0];
                el.src = photo.src.small;
              } else {
                el.src = `https://via.placeholder.com/50x50?text=${encodeURIComponent(word)}`;
              }
            })
            .catch(err => {
              console.error("Error fetching vocabulary image for", word, err);
              el.src = `https://via.placeholder.com/50x50?text=${encodeURIComponent(word)}`;
            });
        });
      }
      
      /* --- JUEGOS --- */
      
      // Muestra popup de selección de juego
      showGameSelectionPopup() {
        const popup = document.createElement('div');
        popup.className = 'game-popup';
        let gameListHTML = `<h2>Selecciona un Juego</h2><ul>`;
        this.currentStory.games.forEach((gameObj) => {
          const gameKey = Object.keys(gameObj)[0];
          const gameData = gameObj[gameKey];
          gameListHTML += `<li data-game="${gameKey}">${gameData.title}</li>`;
        });
        gameListHTML += `</ul><button class="popup-close btn-professional">Cerrar</button>`;
        popup.innerHTML = gameListHTML;
        document.body.appendChild(popup);
        popup.querySelector('.popup-close').addEventListener('click', () => { popup.remove(); });
        popup.querySelectorAll('li').forEach(li => {
          li.style.cursor = 'pointer';
          li.addEventListener('click', () => {
            const selectedGame = li.getAttribute('data-game');
            popup.remove();
            this.startGame(selectedGame);
          });
        });
      }
      
      // Inicia el juego seleccionado y muestra la vista de juego
      startGame(gameKey) {
        document.getElementById('storyView').style.display = 'none';
        document.getElementById('gameView').style.display = 'block';
        document.getElementById('gameContent').innerHTML = '';
        switch (gameKey) {
          case 'game1': this.launchOrderingSentencesGame(); break;
          case 'game2': this.launchTriviaGame(); break;
          case 'game3': this.launchMemoryCardsGame(); break;
          case 'game4': this.launchCompleteWordGame(); break;
          default: console.error('Juego no reconocido:', gameKey);
        }
      }
      
      // Sale del juego y vuelve a la vista de la historia
      exitGame() {
        document.getElementById('gameView').style.display = 'none';
        document.getElementById('storyView').style.display = 'block';
      }
      
      /* Juego 1: Ordenar Palabras */
      launchOrderingSentencesGame() {
        this.game1Index = 0;
        this.renderOrderingQuestion();
      }
      
      renderOrderingQuestion() {
  const gameData = this.currentStory.games.find(g => g.game1).game1;
  
  // Se combinan las oraciones guardadas (savedSentences) y las predeterminadas, colocando primero las guardadas
  let sentences = [];
  if (this.savedSentences.length > 0) {
    // Extraemos las oraciones guardadas
    sentences = this.savedSentences.map(item => item.sentence);
  }
  // Luego agregamos las oraciones por defecto
  sentences = sentences.concat([...gameData.sentences]);
  
  // Mostramos en consola la data final de oraciones
  console.log("Juego 1 - Sentences:", sentences);
  
  // Actualizamos las traducciones para oraciones guardadas:
  this.savedSentences.forEach(item => {
    this.currentStory.translation[item.sentence.toLowerCase()] = item.translation;
  });
  
  // Verificamos si ya se han agotado todas las oraciones
  if (this.game1Index >= sentences.length) {
    document.getElementById('gameContent').innerHTML = `
      <div class="card ordering-game-card">
        <div class="card-header">
          <h2 class="ordering-game-title">${gameData.title}</h2>
          <div class="ordering-progress">${sentences.length}/${sentences.length}</div>
        </div>
        <div class="card-body">
          <p>Juego terminado. ¡Felicidades!</p>
        </div>
      </div>`;
    return;
  }
  
  // Se obtiene la oración actual (ya sea de las guardadas o predeterminadas)
  const sentence = sentences[this.game1Index];
  console.log("Juego 1 - Oración actual:", sentence);
  
  this.correctWords = sentence.split(" ");
  
  // Se crea la pool de palabras mezcladas
  this.availablePoolWords = this.shuffleArray([...this.correctWords]);
  console.log("Juego 1 - Pool de palabras:", this.availablePoolWords);
  
  this.orderingAnswer = [];
  
  const container = document.getElementById('gameContent');
  container.innerHTML = `
    <div class="card ordering-game-card">
      <div class="card-header">
        <h2 class="ordering-game-title">${gameData.title}</h2>
        <div class="ordering-progress">${this.game1Index + 1}/${sentences.length}</div>
      </div>
      <div class="card-body">
        <p class="ordering-instruction"><strong>Ordena las palabras:</strong></p>
        <div class="pool ordering-word-pool"></div>
        <p class="ordering-response-title"><strong>Tu respuesta:</strong></p>
        <div class="answer ordering-answer-panel"></div>
        <p class="result ordering-result"></p>
        <button class="retry-btn">Reintentar</button>
      </div>
    </div>`;
  
  // Renderizamos la pool y la respuesta actual
  this.renderPool();
  this.renderOrderingAnswer();
  
  // Evento para "Reintentar": reinicia la respuesta y la pool
  const retryButton = document.querySelector('.retry-btn');
  retryButton.addEventListener('click', () => {
    this.orderingAnswer = [];
    this.availablePoolWords = this.shuffleArray([...this.correctWords]);
    console.log("Juego 1 - Nueva pool tras reintentar:", this.availablePoolWords);
    this.renderPool();
    this.renderOrderingAnswer();
    document.querySelector('.ordering-result').textContent = '';
  });
}





renderPool() {
  const poolContainer = document.querySelector('.ordering-word-pool');
  poolContainer.innerHTML = this.availablePoolWords
    .map((word, idx) => `<button class="word-btn" data-index="${idx}">${word}</button>`)
    .join('');
  
  // Asignar evento a cada botón: al hacer click, se remueve la palabra de la pool y se agrega a la respuesta.
  poolContainer.querySelectorAll('.word-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const idx = parseInt(btn.getAttribute('data-index'));
      const selectedWord = this.availablePoolWords.splice(idx, 1)[0];
      this.orderingAnswer.push({ word: selectedWord });
      // Re-renderizamos la pool y la respuesta
      this.renderPool();
      this.renderOrderingAnswer();
      // Si ya se han seleccionado todas las palabras, se compara la respuesta
      if (this.orderingAnswer.length === this.correctWords.length) {
        const userSentence = this.orderingAnswer.map(item => item.word).join(" ");
        const correctSentence = this.correctWords.join(" ");
        const resultP = document.querySelector('.ordering-result');
        if (userSentence.trim() === correctSentence.trim()) {
          resultP.textContent = '¡Correcto!';
          setTimeout(() => { 
            this.game1Index++; 
            this.renderOrderingQuestion(); 
          }, 1500);
        } else {
          resultP.textContent = 'Orden incorrecto, intenta de nuevo.';
        }
      }
    });
  });
}



renderOrderingAnswer() {
  const answerDiv = document.querySelector('.ordering-answer-panel');
  let displayAnswer = [];
  let i = 0;
  // Recorremos el arreglo de respuesta y combinamos dos palabras si forman un phrasal.
  while(i < this.orderingAnswer.length) {
    let word = this.orderingAnswer[i].word;
    let translation = "";
    if (this.currentStory && this.currentStory.translation) {
      translation = this.currentStory.translation[word.toLowerCase()] || "";
    }
    // Si hay siguiente palabra, probar a combinar para ver si es un phrasal
    if (i < this.orderingAnswer.length - 1) {
      let potential = word + " " + this.orderingAnswer[i+1].word;
      if (this.currentStory && this.currentStory.translation && this.currentStory.translation[potential.toLowerCase()]) {
        let combinedTranslation = this.currentStory.translation[potential.toLowerCase()];
        displayAnswer.push({ type: "phrasal", indices: [i, i+1], word: potential, translation: combinedTranslation });
        i += 2;
        continue;
      }
    }
    displayAnswer.push({ type: "single", index: i, word: word, translation: translation });
    i++;
  }
  
  // Construimos el HTML para el panel de respuesta
  let answerHTML = "";
  displayAnswer.forEach(item => {
    if (item.type === "phrasal") {
      answerHTML += `<span data-index="${item.indices[0]}" data-count="2" style="margin: 0 5px; cursor: pointer; display: inline-block; text-align: center;">
            <div class="answer-word">${item.word}</div>
            <div class="answer-translation">${item.translation}</div>
        </span>`;
    } else {
      answerHTML += `<span data-index="${item.index}" data-count="1" style="margin: 0 5px; cursor: pointer; display: inline-block; text-align: center;">
            <div class="answer-word">${item.word}</div>
            <div class="answer-translation">${item.translation}</div>
        </span>`;
    }
  });
  answerDiv.innerHTML = answerHTML;
  
  // Permite eliminar la palabra o el grupo (phrasal) al hacer click, regresándola a la pool
  answerDiv.querySelectorAll('span').forEach(span => {
    span.addEventListener('click', () => {
      const startIndex = parseInt(span.getAttribute('data-index'));
      const count = parseInt(span.getAttribute('data-count'));
      // Recuperamos las palabras que se van a remover (en orden original)
      const removed = this.orderingAnswer.splice(startIndex, count);
      // Agregamos las palabras removidas de vuelta a la pool (al final) y remezclamos
      this.availablePoolWords = this.availablePoolWords.concat(removed.map(item => item.word));
      this.availablePoolWords = this.shuffleArray(this.availablePoolWords);
      this.renderPool();
      this.renderOrderingAnswer();
    });
  });
}
  
      
      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
      
      /* Juego 2: Trivia */
      launchTriviaGame() {
        const gameData = this.currentStory.games.find(g => g.game2).game2;
        this.currentTriviaIndex = 0;
        this.triviaScore = 0;
        const container = document.getElementById('gameContent');
        container.innerHTML = `
          <div id="game2Container"></div>`;
        this.renderTriviaQuestion();
      }
      
      renderTriviaQuestion() {
  const gameData = this.currentStory.games.find(g => g.game2).game2;
  const container = document.getElementById('game2Container');
  if (this.currentTriviaIndex >= gameData.questions.length) {
    container.innerHTML = `
      <div class="card trivia-game-card">
        <div class="card-header">
          <h2 class="trivia-game-title">${gameData.title}</h2>
          <div class="trivia-progress">${gameData.questions.length}/${gameData.questions.length}</div>
        </div>
        <div class="card-body">
          <p>Juego terminado. Puntaje: ${this.triviaScore} de ${gameData.questions.length}</p>
        </div>
      </div>`;
    return;
  }
  
  const questionObj = gameData.questions[this.currentTriviaIndex];
  container.innerHTML = `
    <div class="card trivia-game-card">
      <div class="card-header">
        <h2 class="trivia-game-title">${gameData.title}</h2>
        <div class="trivia-progress">${this.currentTriviaIndex + 1}/${gameData.questions.length}</div>
      </div>
      <div class="card-body">
        <div class="question">${questionObj.question}</div>
        <div class="options trivia-options">
          ${questionObj.options.map(option => `<button class="word-btn" data-option="${option}">${option}</button>`).join('')}
        </div>
        <p class="result trivia-result"></p>
      </div>
    </div>`;
  
  // Reproduce la pregunta en voz alta.
  this.speakText(questionObj.question);
  
  // Asigna eventos a cada opción.
  container.querySelectorAll('.trivia-options button').forEach(btn => {
    btn.addEventListener('click', () => {
      const selected = btn.getAttribute('data-option');
      this.speakText(selected);
      const resultP = container.querySelector('.trivia-result');
      if (selected === questionObj.correct_answer) {
        resultP.textContent = '¡Correcto!';
        resultP.classList.add('animate-correct');
      } else {
        resultP.textContent = 'Incorrecto';
        resultP.classList.add('animate-incorrect');
      }
      setTimeout(() => {
        resultP.classList.remove('animate-correct', 'animate-incorrect');
        this.currentTriviaIndex++;
        this.renderTriviaQuestion();
      }, 1500);
    });
  });
}
      
      /* Juego 3: Memory Cards (Se mantiene sin cambios) */
      launchMemoryCardsGame() {
  const gameData = this.currentStory.games.find(g => g.game3).game3;
  
  // Obtenemos el vocabulario por defecto del juego 3
  let vocabulary = [...gameData.vocabulary];
  
  // Si hay palabras guardadas, se agregan al vocabulario
  if (this.savedWords.length > 0) {
    vocabulary = vocabulary.concat(this.savedWords.map(item => item.word));
  }
  
  // Eliminamos duplicados (comparando en minúsculas)
  vocabulary = [...new Set(vocabulary.map(word => word.toLowerCase()))];
  
  // Mostramos en consola el vocabulario final que se usará
  console.log("Juego 3 - Vocabulary:", vocabulary);
  
  // Creamos las tarjetas (duplicadas para formar parejas)
  let cards = [];
  vocabulary.forEach((word, index) => {
    cards.push({ pairId: index, word: word });
    cards.push({ pairId: index, word: word });
  });
  
  // Se mezclan las tarjetas
  cards = this.shuffleArray(cards);
  
  // Mostramos en consola la data de las tarjetas
  console.log("Juego 3 - Cards:", cards);
  
  const container = document.getElementById('gameContent');
  container.innerHTML = `<h2>${gameData.title}</h2>
    <div id="game3Container">
      ${cards.map((card, i) => {
        return `<div class="memory-card" data-pair="${card.pairId}" data-index="${i}">
                  <div class="card-back">?</div>
                  <div class="card-face">
                    <div class="card-image" data-query="${card.word}"></div>
                    <div class="card-text">${card.word}</div>
                  </div>
                </div>`;
      }).join('')}
    </div>
    <p id="memoryResult"></p>`;
  
  // Se asignan los eventos para cada tarjeta
  this.cards = Array.from(document.querySelectorAll('.memory-card'));
  this.cards.forEach(cardEl => {
    cardEl.addEventListener('click', () => {
      const word = cardEl.querySelector('.card-text').textContent;
      this.speakText(word);
      this.handleMemoryCardClick(cardEl);
    });
  });
  
  this.loadMemoryCardImages();
}

      
      handleMemoryCardClick(cardEl) {
        if (this.memoryLock || cardEl.classList.contains('flipped') || cardEl.classList.contains('matched')) return;
        cardEl.querySelector('.card-back').style.display = 'none';
        cardEl.querySelector('.card-face').style.display = 'block';
        cardEl.classList.add('flipped');
        if (!this.memoryFirstCard) {
          this.memoryFirstCard = cardEl;
        } else {
          if (cardEl.getAttribute('data-pair') === this.memoryFirstCard.getAttribute('data-pair')) {
            cardEl.classList.add('matched');
            this.memoryFirstCard.classList.add('matched');
            this.memoryMatches++;
            this.memoryFirstCard = null;
            if (this.memoryMatches === this.memoryTotalPairs) {
              document.getElementById('memoryResult').textContent = '¡Ganaste!';
            }
          } else {
            this.memoryLock = true;
            setTimeout(() => {
              cardEl.querySelector('.card-back').style.display = 'flex';
              cardEl.querySelector('.card-face').style.display = 'none';
              cardEl.classList.remove('flipped');
              this.memoryFirstCard.querySelector('.card-back').style.display = 'flex';
              this.memoryFirstCard.querySelector('.card-face').style.display = 'none';
              this.memoryFirstCard.classList.remove('flipped');
              this.memoryFirstCard = null;
              this.memoryLock = false;
            }, 1000);
          }
        }
      }
      
      loadMemoryCardImages() {
        const imgContainers = document.querySelectorAll('.card-image');
        imgContainers.forEach(el => {
          const query = el.getAttribute('data-query');
          axios.get(`https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=1`, { headers: { Authorization: PEXELS_API_KEY } })
            .then(response => {
              if (response.data.photos && response.data.photos.length > 0) {
                const photo = response.data.photos[0];
                el.innerHTML = `<img src="${photo.src.small}" alt="${query}" style="width:100%; height:100%; object-fit:cover;">`;
              } else {
                el.innerHTML = `<img src="https://via.placeholder.com/100x80?text=${encodeURIComponent(query)}" alt="${query}">`;
              }
            })
            .catch(err => {
              console.error("Error fetching image for memory card:", query, err);
              el.innerHTML = `<img src="https://via.placeholder.com/100x80?text=${encodeURIComponent(query)}" alt="${query}">`;
            });
        });
      }
      
      /* Juego 4: Completa la Palabra */
      launchCompleteWordGame() {
  const gameData = this.currentStory.games.find(g => g.game4).game4;
  this.currentFillIndex = 0;
  this.fillScore = 0;
  // Inicializa currentFillData para la primera pregunta
  this.currentFillData = this.generateFillData(gameData.questions[this.currentFillIndex].answer);
  const container = document.getElementById('gameContent');
  container.innerHTML = `
    <div id="game4Container" class="completa-game-card">
      <h2>${gameData.title}</h2>
      <div class="incomplete-sentence">${gameData.questions[this.currentFillIndex].sentence}</div>
      <div class="fill-answer" id="fillAnswerArea">
        ${this.currentFillData.fillWords.map(wordData => {
          return wordData.display.map(char => `<span>${char === null ? '_' : char}</span>`).join('');
        }).join('&nbsp;&nbsp;')}
      </div>
      <div class="letter-pool" id="letterPool">
        ${this.currentFillData.pool.map((letter, i) => `<button class="btn-professional" data-index="${i}">${letter}</button>`).join('')}
      </div>
      <button id="resetFillBtn" class="action-btn btn-professional">Reiniciar</button>
      <p id="fillFeedback"></p>
    </div>`;
  
  // Ahora renderFillQuestion() encontrará el contenedor "game4Container"
  this.renderFillQuestion();
}




      generateFillData(answer) {
        answer = answer.toUpperCase();
        const words = answer.split(" ");
        const fillWords = words.map(word => {
          if (word.length <= 2) return { original: word, display: word.split(''), missingIndices: [] };
          const numMissing = Math.ceil(word.length / 3);
          let possible = [];
          for (let i = 1; i < word.length - 1; i++) { possible.push(i); }
          let missingIndices = [];
          while (missingIndices.length < numMissing && possible.length > 0) {
            const randIndex = Math.floor(Math.random() * possible.length);
            missingIndices.push(possible[randIndex]);
            possible.splice(randIndex, 1);
          }
          missingIndices.sort((a, b) => a - b);
          const display = word.split('').map((char, idx) => missingIndices.includes(idx) ? null : char);
          return { original: word, display, missingIndices };
        });
        let missingLetters = [];
        fillWords.forEach(wordData => {
          wordData.missingIndices.forEach(idx => { missingLetters.push(wordData.original[idx]); });
        });
        const distractorTarget = missingLetters.length + 3;
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        while (missingLetters.length < distractorTarget) {
          const randChar = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
          missingLetters.push(randChar);
        }
        missingLetters = this.shuffleArray(missingLetters);
        return { fillWords, pool: missingLetters };
      }
      
      renderFillQuestion() {
  const container = document.getElementById('game4Container');
  if (!container) {
    console.error('No se encontró el contenedor con id "game4Container"');
    return;
  }
  
  const gameData = this.currentStory.games.find(g => g.game4).game4;
  if (this.currentFillIndex >= gameData.questions.length) {
    container.innerHTML = `<p>Juego terminado. Puntaje: ${this.fillScore} de ${gameData.questions.length}</p>`;
    return;
  }
  
  const questionObj = gameData.questions[this.currentFillIndex];
  this.currentFillData = this.generateFillData(questionObj.answer);
  container.innerHTML = `
    <div class="question">Completa la palabra:</div>
    <div class="incomplete-sentence">${questionObj.sentence}</div>
    <div class="fill-answer" id="fillAnswerArea">
      ${this.currentFillData.fillWords.map(wordData => {
        return wordData.display.map(char => `<span>${char === null ? '_' : char}</span>`).join('');
      }).join('&nbsp;&nbsp;')}
    </div>
    <div class="letter-pool" id="letterPool">
      ${this.currentFillData.pool.map((letter, i) => `<button class="btn-professional" data-index="${i}">${letter}</button>`).join('')}
    </div>
    <button id="resetFillBtn" class="action-btn btn-professional">Reiniciar</button>
    <p id="fillFeedback"></p>
  `;
  
  const poolButtons = container.querySelectorAll('#letterPool button');
  poolButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const letter = btn.textContent;
      this.speakText(letter);
      const answerSpans = container.querySelectorAll('#fillAnswerArea span');
      for (let span of answerSpans) {
        if (span.textContent === '_') {
          span.textContent = letter;
          btn.disabled = true;
          break;
        }
      }
      this.checkFillCompletion();
    });
  });
  
  document.getElementById('resetFillBtn').addEventListener('click', () => {
    const answerSpans = container.querySelectorAll('#fillAnswerArea span');
    let idx = 0;
    this.currentFillData.fillWords.forEach(wordData => {
      wordData.display.forEach((char) => {
        answerSpans[idx].textContent = (char === null) ? '_' : char;
        idx++;
      });
    });
    container.querySelectorAll('#letterPool button').forEach(btn => btn.disabled = false);
  });
}


      
      checkFillCompletion() {
        const container = document.getElementById('game4Container');
        const answerSpans = container.querySelectorAll('#fillAnswerArea span');
        let currentAnswer = "";
        answerSpans.forEach(span => { currentAnswer += span.textContent; });
        if (!currentAnswer.includes('_')) {
          let idx = 0, reconstructed = "";
          this.currentFillData.fillWords.forEach(wordData => {
            let wordStr = "";
            for (let i = 0; i < wordData.original.length; i++) {
              wordStr += answerSpans[idx].textContent;
              idx++;
            }
            reconstructed += wordStr + " ";
          });
          reconstructed = reconstructed.trim();
          const feedback = container.querySelector('#fillFeedback');
          const gameData = this.currentStory.games.find(g => g.game4).game4;
          const questionObj = gameData.questions[this.currentFillIndex];
          if (reconstructed === questionObj.answer.toUpperCase()) {
            feedback.textContent = '¡Correcto!';
            this.fillScore++;
          } else {
            feedback.textContent = 'Incorrecto, intenta de nuevo.';
          }
          setTimeout(() => {
            this.currentFillIndex++;
            this.renderFillQuestion();
          }, 1500);
        }
      }



















    }
    




    function showSpinner() {
  const spinner = document.querySelector('.loading-screen');
  // Mover el spinner al final del body si no está allí
  if (spinner.parentElement !== document.body) {
    document.body.appendChild(spinner);
  }
  spinner.style.display = 'grid';
}

function hideSpinner() {
  const spinner = document.querySelector('.loading-screen');
  spinner.style.display = 'none';
}


window.speechSynthesis.onvoiceschanged = function() {
  const voces = window.speechSynthesis.getVoices();
  console.log(voces); // Ver todas las voces instaladas
};



    document.addEventListener('DOMContentLoaded', () => {
      const manager = new StoryManager();
    });
  </script>
</body>
</html>
