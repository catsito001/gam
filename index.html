<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />


   <meta property="og:title"   content="Título de la página o post" />
  <meta property="og:description"
        content="Aprende y practica ingles leyendo historias seleccionadas." />
  <meta property="og:image"
        content="https:www.gawipy.site/portada/portada.png" />
  <meta property="og:image:width"  content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:url"     content="https://www.gawipy.site" />
  <meta property="og:type"    content="website" />


  <title>Interactive English Stories</title>
  
  <!-- Fuentes e Íconos -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
  
  <!-- Axios para cargar la data -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="mespeak/mespeak.full.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vosk-browser@0.0.8/dist/vosk.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <style>
    /* Variables y estilos base - Modo Oscuro */
    :root {
      --primary-600: #6366f1;
      --primary-500: #818cf8;
      --primary-600-hover: #4f46e5;
      --accent: #ef4444;
      --surface-100: #1a1a1a;
      --text-primary: #e5e7eb;
      --radius-md: 12px;
      --shadow-md: 0 4px 6px rgba(0,0,0,0.3);
      --transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
      --grid-gap: 10px;
      --gradient-purple: linear-gradient(135deg, #2c2d61 0%, #8b5cf6 100%);
      --gradient-teal: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
    }
    
    /* Reset y estilos generales */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Inter', sans-serif; 
      background-color: #121212; 
      color: var(--text-primary); 
      margin-top: -15px;  
    }
    
    /* ============================ */
    /* Botones Interactivos         */
    /* ============================ */
/* 1) Nuevas variables para controlar el active */
.btn-professional {
  --btn-bg: var(--gradient-purple);
  --btn-bg-active-start: #4f46e5;
  --btn-bg-active-end:   #4338ca;
  --btn-border-active:   #e0e7ff;
  --btn-text-active:     #f3f4f6;

   --btn-active-start:  #2b2436;  /* ámbar */
  --btn-active-end:    #0c0d16;  /* naranja vivo */
  --btn-active-text:   #ffffff;
}

/* 2) Estado normal */
.btn-professional {
  background: var(--btn-bg);
  color: white;
  border: none;
  border-radius: var(--radius-md);
  padding: 6px 12px;
  font-weight: 600;
  letter-spacing: 0.5px;
  position: relative;
  overflow: hidden;
  transition: var(--transition), background 0.2s;
  box-shadow: 0 4px 15px rgba(99,102,241,0.3);
  cursor: pointer;
}

/* 3) Efecto de brillo en hover */
/* Variables de color (añádelas junto al resto de --btn-*) */


/* 4) Estado active más destacado */
.btn-professional.active {
  /* usa el naranja-ámbar en lugar de morado */
  background: linear-gradient(135deg,
    var(--btn-active-start),
    var(--btn-active-end)
  );
  color: var(--btn-active-text);
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  transform: translateY(0) scale(1.04);
  border: 2px solid var(--btn-active-text);
}

/* línea inferior blanca para marcar mejor */
.btn-professional.active::before {
  
  position: absolute;
  bottom: -1px;
  left: 10%;
  width: 80%;
  height: 4px;
  background: var(--btn-active-text);
  border-radius: 2px;
}
    
    /* ============================ */
    /* Loading Screen               */
    /* ============================ */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--surface-100);
  display: flex;               /* <<< FLEX en columna */
  flex-direction: column;
  justify-content: center;     /* centra verticalmente */
  align-items: center;         /* centra horizontalmente */
  gap: 0.25rem;                /* solo 4px de separación */
  padding: 1rem;               /* opcional, para que no quede pegado al borde */
  z-index: 9999;
}
    .spinner {
       width: 48px;
  height: 48px;
  border: 3px solid #e2e8f0;
  border-top-color: var(--primary-500);
  border-radius: 50%;
  animation: spin 1s linear infinite;
    }


    /* Texto bajo el spinner */
.loading-info {
  margin-top: 0;
  text-align: center;
}
.loading-info small {
   font-size: 0.75rem;
  color: var(--text-primary);
  white-space: nowrap;
}



    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* ============================ */
    /* Stories List                 */
    /* ============================ */
    .stories-view { 
      max-width: 1400px; 
      margin: 0 auto; 
      padding: 1rem; 
    }
    .stories-header { 
      text-align: center; 
       position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000; /* asegúrate de que esté por encima del resto */
  background: #1f1f1f; /* o el color/degradado que uses */
  padding: 0.5rem 0rem; /* ajusta según tu diseño */
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .stories-header h1 { 
      font-size: 1.5rem; 
      font-weight: 700; 
    }
    .stories-header p { 
      color: var(--text-primary); 
    }
    .stories-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 0.5rem;
      padding: 1px 0;
      margin-top: 141px;
    }
    /* Tarjeta de historia */
    .story-card {
      background: #2d2d2d;
      border: 1px solid #3d3d3d;
      border-radius: var(--radius-md);
      padding: 0.5rem;
      transition: var(--transition);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
      text-align: center;
    }
    .story-card::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: var(--gradient-purple);
      opacity: 0.1;
      transform: rotate(45deg);
      transition: opacity 0.3s;
    }
    .story-card:hover {
      transform: translateY(-5px) scale(1.02);
      border-color: var(--primary-500);
    }
    .story-card:hover::before { opacity: 0.15; }
    .story-card h3 { 
      color: #fff; 
      font-size: 1.0rem; 
      margin-bottom: 0.5rem; 
      position: relative; 
      z-index: 1; 
    }
    .story-card p { 
      color: #a1a1aa; 
      font-size: 0.85rem; 
      position: relative; 
      z-index: 1; 
    }
    
    /* ============================ */
    /* Story View                   */
    /* ============================ */
    .story-view {
      max-width: 800px;
      margin: 1rem auto;
      background: #1f1f1f;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      display: flex;
      flex-direction: column;
    }
    .story-header {
       position: relative; 
      display: flex;
      align-items: center;
      padding: 0.3rem;
      background: #1f1f1f;
      border-bottom: 1px solid #3d3d3d;
    }
    .header-left { 
      display: flex;
  flex-direction: column;
  align-items: flex-start; /* Si deseas que ambos queden a la izquierda */
    }
    .header-left button {
      background: var(--gradient-purple);
      color: white;
      border: none;
      width: 50px;
      height: 35px;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: var(--transition);
    }
    .header-left button:hover { transform: scale(1.1); }
    .header-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      font-weight: 600;
      text-align: left;
      white-space: normal;
      margin-left: 10px;

    }
    .header-content { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
    }
    .header-right { 
      margin-top: 0.5rem; 
      display: flex; 
      justify-content: flex-end; 
    }
    .progress-container {
      margin-top: 0.3rem;
      width: 100%;
      max-width: 250px;
      height: 12px;
      position: relative;
    }
    .progress-bar {
      width: 100%;
      height: 100%;
      background: #333;
      border-radius: 6px;
      overflow: hidden;
      margin-left: 10px;
    }
    .progress {
      height: 100%;
      width: 0;
      background: var(--gradient-purple);
      transition: width 0.4s ease-out;
    }
    .progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.9rem;
      color: var(--text-primary);
    }
    .story-content { 
      padding: 0.2rem; 
      flex: 1; 
      background: #181818;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .text-cards-container { width: 100%; }
    .text-card {
      display: none;
      padding: 0.5rem;
      background: #181818;
      border: 1px solid #3d3d3d;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      margin: 0.1rem 0.1rem 1.5rem;

    }
    .text-card.active { display: block; }
    .sentence-container { margin-bottom: 0.1rem; }
    .english-text {
      font-size: 1.3rem;
      line-height: 2.4rem;
      margin: 0.2rem 0;
      position: relative;
      background: #222020; 
      border-radius: 5px;
      padding: 3px 3px 3px 3px;
      
    }
    .full-translation {
      font-size: 0.8rem;
      background: #333;
      color: #d1d5db;
      padding: 0.4rem;
      border-radius: var(--radius-md);
      margin-bottom: 0.2rem;
      border-left: 4px solid var(--primary-500);
    }
    /* Botones de toggle para traducciones y lista */
    .toggle-container { text-align: right; margin-top: 0.1rem; }
    .toggle-btn-wrapper { display: inline-block; }
    
    /* ============================ */
    /* Controles y Popups           */
    /* ============================ */
    .controls-footer {
       position: fixed;             /* Fija la posición en pantalla */
  bottom: 0;                   /* Lo ubica en la parte inferior */
  left: 0;
  width: 100%;                 /* Que ocupe todo el ancho */
  z-index: 9999;               /* Lo asegura encima de todo */
  display: flex;
  justify-content: center;
  gap: 0.7rem;
  padding: 0.3rem;
  border-top: 1px solid #3d3d3d;
  background-color: #121212;   /* Fondo para evitar transparencia */
    }
    .control-btn {
      width: 60px;
      height: 30px;
      border: none;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, #282a72 0%, #5161e9 100%);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: var(--transition);
    }
    .control-btn:hover { transform: scale(1.1); }
    .word-popup, .saved-list-popup, .game-popup {
      background: #2d2d2d;
      border: 1px solid #3d3d3d;
      box-shadow: 0 12px 32px rgba(0,0,0,0.3);
      border-radius: var(--radius-md);
      padding: 1rem;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      max-width: 90%;
      width: 325px;
      color: var(--text-primary);

      align-items: center;          /* Centra horizontalmente */
  justify-content: center;      /* Centra verticalmente */
  text-align: center;
    }

    
    .word-popup h2, .saved-list-popup h2, .game-popup h2 { margin-top: 0; }
    .popup-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
     
    }
    .word-popup button, .saved-list-popup button, .game-popup button {
      background: linear-gradient(135deg, #2c2d61 0%, #8b5cf6 100%);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: background 0.3s;
      margin: 1px;
    }
    .word-popup button:hover, .saved-list-popup button:hover, .game-popup button:hover {
      background: var(--primary-600);
    }
    



    .saved-list-popup {
  width: 360px;            /* un poco más ancho para que no quede apretado */
  max-width: 90%;
  display: block;          /* ya no lo tratamos como flexbox */
  padding: 1.5rem;
  text-align: left;        /* los textos van alineados a la izquierda */
}

/* Titulares con separación y peso */
.saved-list-popup h2 {
  margin-top: 0;
  margin-bottom: 1rem;
  font-size: 1.4rem;
  font-weight: 700;
}
.saved-list-popup h3 {
  margin: 1rem 0 0.5rem;
  font-size: 1.1rem;
  font-weight: 600;
  border-bottom: 1px solid #444;
  padding-bottom: 0.25rem;
}

/* Listas sin bullets y con separación clara */
.saved-list-popup ul {
  list-style: none;
  margin: 0;
  padding: 0;
}
.saved-list-popup ul li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.4rem 0;
  border-bottom: 1px solid #3d3d3d;
}
.saved-list-popup ul li:last-child {
  border-bottom: none;
}

/* El texto de cada ítem ocupa todo el espacio posible */
.saved-list-popup ul li span {
  flex: 1;
  margin-right: 0.5rem;
  word-break: break-word;
}

/* El botón de eliminar, más chico y sin margen extra */
.saved-list-popup ul li button {
  padding: 0.25rem 0.5rem;
  font-size: 0.85rem;
}

/* Botones de acción al pie, alineados a la derecha */
.saved-list-popup .popup-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
  margin-top: 1rem;
}

    .word-popup .popup-image {
  /* conserva el margin‑top/bottom que quieras */
  margin: 10px auto;   /* 5px arriba/abajo, auto izquierda/derecha = centrar */
}


    /* Popup para selección de juego */
  .game-popup ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

.game-popup li {
  position: relative;
  display: block;
  width: 100%;
  padding: 14px 16px;
  margin: 8px 0;
      background: linear-gradient(135deg, #27297d, #3a38e8);
        /* fondo claro */
  border: 1px solid #ddd;      /* borde suave */
  border-radius: 8px;          /* esquinas redondeadas */
  color: #ffffff;                 /* texto oscuro */
font-family: 'Orbitron', sans-serif;  font-size: 1rem;
font-weight: 600;
  text-align: center;          /* centra el texto */
  cursor: pointer;
  transition: background 0.2s, transform 0.2s, box-shadow 0.2s;
}

.game-popup li:hover {
  background: #052864;         /* ligero azul al pasar */
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.game-popup li:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Si usas un icono dentro, ajústalo así: */
.game-popup li .icon {
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  opacity: 0.6;
  transition: opacity 0.2s;
}

.game-popup li:hover .icon {
  opacity: 1;
}
    





    /* ============================ */
    /* Game View                    */
    /* ============================ */
    #gameView {
      display: none;
      height: 100vh;
      overflow: hidden;
      position: relative;
      background: #1a1a1a;
    }
    #gameView .exit-game {
      position: absolute;
      top: 25px;
      right: 10px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.5rem;
      cursor: pointer;
      transition: background 0.3s;
      z-index: 101;
    }
    #gameView .exit-game:hover { background: #c0392b; }
    #gameContent { 
      height: 100%; 
      overflow: auto; 
      padding-top: 60px; 
      
      max-width: 1000px;
      margin: 0 auto;
    }
    
    /* ============================ */
    /* Estilos para Juegos          */
    /* ============================ */
    /* Juego 1: Ordenar Palabras */
    .ordering-game-card {
      background-color: #222;
      border: 1px solid #444;
      border-radius: var(--radius-md);
      padding: 5px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      color: #fff;
      min-height: 450px;
      box-sizing: border-box;
      margin: 5px;
    }
    .ordering-game-card .card-header {
      padding: 15px;
      text-align: center;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .ordering-game-title {
      margin: 0;
      font-size: 1.8rem;
      font-family: 'Orbitron', sans-serif;
    }
    .ordering-progress { font-size: 1rem; color: #bbb; }
    .ordering-game-card .card-body { padding: 5px; }
    .ordering-instruction { text-align: center; margin-bottom: 10px; font-size: 1.1rem; }
    .ordering-word-pool {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .ordering-word-pool .word-btn {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 20px;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .ordering-word-pool .word-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .ordering-word-pool .word-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, #2575fc, #6a11cb);
    }
    .ordering-answer-panel {
      min-height: 50px;
      padding: 5px 5px;
      margin-bottom: 15px;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      word-wrap: break-word;
    }
    .answer-word { font-size: 1.5rem; font-weight: bold; }
    .answer-translation {
      font-size: 0.9rem;
      color: #ccc;
      margin-top: 2px;
    }
    .ordering-response-title { text-align: center; margin-bottom: 10px; }
    .ordering-result { text-align: center; font-size: 1.2rem; font-weight: 500; margin-top: 10px; }
    .retry-btn {
      background: linear-gradient(135deg, #ff416c, #ff4b2b);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      margin: 10px auto;
      display: block;
    }
    .retry-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, #ff4b2b, #ff416c);
    }
    
    /* Juego 2: Trivia */
    .trivia-game-card {
      background-color: #222;
      border: 1px solid #444;
      border-radius: var(--radius-md);
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      color: #fff;
      min-height: 500px;
      box-sizing: border-box;
      margin: 5px;
    }
    .trivia-game-card .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
      
    }
    .trivia-game-title {
      font-size: 1rem;
      font-family: 'Orbitron', sans-serif;
      margin: 0;
    }
    .trivia-progress { font-size: 1rem; color: #bbb; }
    .trivia-game-card .card-body { padding: 20px 0; }
    .trivia-options {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-top: 20px;
    }
    #game2Container .trivia-options .word-btn {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      width: 80%;
      max-width: 500px;
    }
    .trivia-options .word-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, #2575fc, #6a11cb);
    }
    .trivia-result {
      text-align: center;
      font-size: 1.5rem;
      margin-top: 10px;
      transition: all 0.3s ease;
    }


    .question {
      font-size: 1.5rem;
      font-family: 'Orbitron', sans-serif;
      margin: 10px;

    }
    @keyframes correctAnimation {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); }
    }
    @keyframes incorrectAnimation {
      0% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      50% { transform: translateX(5px); }
      75% { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }
    .animate-correct {
      animation: correctAnimation 0.5s ease;
      color: #00ff00;
    }
    .animate-incorrect {
      animation: incorrectAnimation 0.5s ease;
      color: #ff0000;
    }
    
    /* Juego 3: Memory Cards */
    #game3Container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      grid-auto-rows: 1fr;
      gap: 10px;
      justify-items: stretch;
      padding: 10px;
      height: 90%;
    }
    @media (max-width: 600px) {
      #game3Container { grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); }
    }
    .memory-card {
      width: 100%;
      height: 100%;
      background: #333;
      border: none;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      overflow: hidden;
      position: relative;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .memory-card:hover { 
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,0,0,0.2);
    }
    .card-back, .card-face {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .card-back {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      font-weight: bold;
      background: var(--gradient-purple);
      color: white;
    }
    .card-face { display: none; text-transform: uppercase; }
    .card-face .card-image {
      width: 100%;
      height: 75%;
      object-fit: cover;
    }
  .card-face .card-text {
  font-size: clamp(0.8rem, 2vw, 1.2rem);
  font-weight: bold;
  padding: 5px;
  text-align: center;
  white-space: normal;        /* Permite que el texto haga salto de línea */
  word-wrap: break-word;      /* Rompe la palabra si es necesario */
  overflow-wrap: anywhere;    /* Alternativa más agresiva para quiebres */
}
    
    /* Juego 4: Completa la Palabra */
    #game4Container {
      background-color: #222;
      border: 1px solid #444;
      border-radius: var(--radius-md);
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      color: #fff;
      min-height: 500px;
      box-sizing: border-box;
      margin: 5px;
    }
    #game4Container .incomplete-sentence {
      font-size: 2.5rem;
      text-align: center;
      margin-bottom: 30px;
      font-family: 'Roboto', sans-serif;
    }
    #game4Container .fill-answer {
      margin: 30px 0;
      font-size: 1.8rem;
      letter-spacing: 6px;
      text-transform: uppercase;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }
    #game4Container .fill-answer span {
      display: inline-block;
      min-width: 30px;
      border-bottom: 2px solid var(--primary-600);
      cursor: pointer;
      font-weight: bold;
      padding: 8px;
      text-align: center;
      transition: border-color 0.2s ease;
      font-family: 'Orbitron', sans-serif;
    }
    #game4Container .fill-answer span:hover { border-color: var(--primary-500); }
    #game4Container .letter-pool {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    #game4Container .letter-pool button {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      font-size: 1.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      width: 20%;
      max-width: 120px;
      text-transform: uppercase;
    }
    #game4Container .letter-pool button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 10px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    }
    #game4Container button.action-btn {
      background: var(--gradient-purple);
      color: #fff;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      margin: 20px auto;
      display: block;
    }
    #game4Container button.action-btn:hover {
      transform: translateY(-3px) scale(1.05);
      background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
    }
    #game4Container #fillFeedback {
      text-align: center;
      font-size: 1.5rem;
      margin-top: 15px;
      font-weight: 500;
    }
    
    /* ============================ */
    /* Interacciones con Palabras   */
    /* ============================ */
    .highlight-word, .phrasal-verb-inline, .vocabulary-inline {
      position: relative;
      cursor: pointer;
      padding: 2px 3px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .highlight-word.active,
    .phrasal-verb-inline.active,
    .vocabulary-inline.active {
        outline: 0.5px solid #ffffff;
      background: linear-gradient(135deg, #242552 0%, #522da7 100%); 
      color: white;
    }
    .phrasal-verb-inline {
      display: inline-block;
      padding: 2px 4px;
      background-color: rgba(37,99,235,0.2);
      transition: background-color 0.3s ease;
    }
    .vocabulary-inline {
      background-color: rgba(16,185,129,0.2);
      transition: background-color 0.3s ease;
    }
    .translation-tooltip {
      position: absolute;
      bottom: 65%;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #0d0f55 0%, #1c559b 100%);
      color: #eee7e7;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 0.8rem;
      white-space: nowrap;
      pointer-events: none;
      z-index: 10;
      margin-bottom: 5px;
      display: none;
      line-height: 0.5rem;
    }
    .phrasal-verb-inline .translation-tooltip {
      
      
    }
    .text-card.show-translations .english-text .translation-tooltip {
      display: block;
    }
    
    /* ============================ */
    /* Estilos de Vocabulario       */
    /* ============================ */
    .vocabulary-container { margin-top: 0.5rem; }
    .vocabulary-words { 
      display: flex; 
      flex-wrap: nowrap; 
      gap: 0.5rem; 
      overflow-x: auto;
      scroll-behavior: smooth;
    }




    .select-voice {
  position: relative;
  
  padding: 5px 10px; /* Ajusta a lo que necesites */
  max-width: 50px;  /* O el ancho que prefieras para este select */
  background-color: #318c8f !important; /* Fondo sólido */
  /* Si prefieres gradiente, descomenta la siguiente línea y comenta la anterior */
  /* background: linear-gradient(135deg, #6366f1, #8b5cf6) !important; */
  color: white !important;
  border: none !important;
  border-radius: 8px !important;
  padding: 9px 9px 8px 15px !important; /* Espacio a la izquierda para el ícono y a la derecha para la flecha */
  font-size: 0.6rem;
  font-weight: 600;
  letter-spacing: 0.5px;
  cursor: pointer;
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  outline: none !important;
  background-image: none !important;
  display: inline-block;
  margin-right: 2px;
  margin-top: 8px;
}

    /* Contenedor de vocabulario: posición relativa para colocar botones */
.vocabulary-container {
  position: relative;
  margin-top: 0.5rem;
}

/* Título del vocabulario */
.vocabulary-title {
  font-size: 0.7rem;
  margin-bottom: 0.2rem;
  color: #a1a1aa;
}



/* Cada bloque de vocabulario no se encoge y se alinea al inicio de la vista */
.vocabulary-word {
  display: flex;
      align-items: center;
      background: linear-gradient(135deg, #0d0f55 0%, #1c559b 100%);
      padding: 0.4rem;
      border-radius: 4px;
      transition: background 0.3s;
      font-size: 0.8rem;
      
      gap: 0.1rem;
}

/* Botones de control del carrusel */
.vocab-carousel-control {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  padding: 0.3rem;
  cursor: pointer;
  z-index: 2;
}

.vocab-carousel-control.left {
  left: 0;
}

.vocab-carousel-control.right {
  right: 0;
}




    .vocabulary-word:hover { background: #3d3d3d; }
    .vocabulary-image {
      flex-shrink: 0;
      width: 50px;
      height: 50px;
      margin-right: 2px;
    }
    .vocabulary-image img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
    }
    .vocabulary-text { 
      display: flex; 
      flex-direction: column; 
      text-align: left; 
    }
    .vocabulary-text strong { font-weight: bold; }
    .vocabulary-translation { font-size: 0.7rem; color: #dadaeb; }





    .header-right {
  margin-top: 0.5rem;
  display: flex;
  justify-content: flex-end;
  gap: 0.2rem;
}

.header-right .play-btn,
.header-right .saved-list-btn {
  border: none;
  border-radius: var(--radius-md);
  padding: 6px 6px;
  font-weight: 600;
  color: white;
  cursor: pointer;
  transition: background 0.3s;
  margin-right: 6px;
}

.header-right .play-btn {
  background: linear-gradient(135deg, #133e19 0%, #46b345 100%);
}

.header-right .play-btn:hover {
  background: #059669;
}

.header-right .saved-list-btn {
  background: linear-gradient(135deg, #615b11 0%, #e1e36d 100%);
  display: flex;
  align-items: center;
}

.header-right .saved-list-btn:hover {
  background: linear-gradient(135deg, #615b11 0%, #e1e36d 100%);
}

.header-right .saved-list-btn i {
  margin-right: 0.3rem;
}

.header-right .saved-list-btn span {
  background: white;
  color: var(--primary-500);
  border-radius: 50%;
  padding: 0 6px;
  font-size: 0.8rem;
  margin-left: 4px;
}








/* Carrusel de imágenes */
.carousel-container {
  position: relative;
  overflow: hidden;
  margin-bottom: 0.3rem;
}

.carousel-inner {
  display: flex;
  flex-direction: row;
  gap: 10px;
  transition: transform 0.5s ease;
  /* Se muestra horizontalmente sin wrap */
  flex-wrap: nowrap;
}

.carousel-item {
  flex-shrink: 0;
  width: 100%;
  display: none;
  justify-content: center;
  align-items: center;
}

.carousel-item.active {
  display: flex;
}

/* Botones de control del carrusel */
.carousel-control {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  padding: 0.5rem 0.75rem;
  cursor: pointer;
  z-index: 2;
}

.carousel-control.prev {
  left: 5px;
}

.carousel-control.next {
  right: 5px;
}

/* Estilos para las imágenes */
.story-image {
  /* Se adapta al tamaño del contenedor */
  max-height: 250px;   /* valor para escritorio, se ajusta en móviles con media queries */
  width: auto;
  object-fit: cover;
  border-radius: var(--radius-md);
  transition: transform 0.3s ease;
}

/* Responsividad: en móviles, reduce la altura pero mantiene la fila horizontal */
@media (max-width: 600px) {
  .story-image {
    max-height: 250px;
  }
}



/* En dispositivos móviles, se ajusta el tamaño de las imágenes sin romper la fila horizontal */
@media (max-width: 600px) {
  .story-image {
    max-height: 250px;    /* Menor altura para dispositivos pequeños */
    /* Puedes ajustar otros valores (p.ej. margenes o flex-basis) si lo crees necesario */
  }
}


.story-card:hover .story-image {
  transform: scale(1.05);
}

.image-container {
  display: flex;
  flex-direction: row;
  gap: 10px;
  overflow-x: auto;   /* Muestra scroll horizontal si es necesario */
  flex-wrap: nowrap;  /* Evita que se envuelvan a una nueva línea */
  justify-content: flex-start;
  padding: 0.5rem;
    }



/* Forzar que el select tenga apariencia de botón */
.custom-select {
  background: linear-gradient(135deg, #2c2d61 0%, #8b5cf6 100%) !important; /* Fondo sólido */
  /* Si prefieres gradiente, descomenta la siguiente línea y comenta la anterior */
  /* background: linear-gradient(135deg, #6366f1, #8b5cf6) !important; */
  color: white !important;
  border: none !important;
  border-radius: 8px !important;
  padding: 8px 20px 8px 23px !important; /* Espacio a la izquierda para el ícono y a la derecha para la flecha */
  font-size: 0.6rem;
  font-weight: 600;
  letter-spacing: 0.5px;
  cursor: pointer;
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
  outline: none !important;
  
}

/* Elimina el outline al enfocar */
.custom-select:focus {
  outline: none !important;
}

/* Estilos para las opciones (nota: algunos navegadores ignoran estos estilos) */
.custom-select option {
  background-color: #6366f1;
  color: white;
}

/* Contenedor del select para agrupar el ícono y eliminar la flecha nativa */
.select-wrapper {
  position: relative;
  display: inline-block;
  margin-right: 2px;
}

/* Ícono de velocidad a la izquierda */
.speed-icon {
  position: absolute;
  left: 7px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 0.8rem;
  color: white;
  pointer-events: none;
}


.voice-icon {
  position: absolute;
  left: 7px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 0.8rem;
  color: white;
  pointer-events: none;
}


/* Flecha personalizada a la derecha */
.select-wrapper::after {
    content: "\f107";                     /* Unicode de fa-angle-down */
    font-family: "Font Awesome 6 Free";
    font-weight: 900;
    font-size: 0.7em;                     /* Ajusta al tamaño que te guste */
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    color: white;
}

    



.english-text.size1 {
  font-size: 1.3rem;
  line-height: 2.2rem;
}
.english-text.size2 {
  font-size: 1.4rem;
  line-height: 2rem;
}
.english-text.size3 {
  font-size: 1.3rem;
  line-height: 2rem;
}





.story-card-inner {
  display: flex;
  align-items: center;
  gap: 1rem; /* espacio entre imagen y texto */
}
.story-card-image {
  flex: 0 0 auto;
  width: 100px;   /* ancho fijo para la imagen, ajustable según diseño */
  height: 100px;  /* alto fijo */
  border-radius: var(--radius-md);
  overflow: hidden;
}
.story-card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;  /* para que la imagen se ajuste sin deformarse */
}
.story-card-text {
  flex: 1;  /* ocupa el resto del espacio */
}








.carousel-container,
.carousel-container .carousel-item {
  position: relative;
  overflow: hidden !important;
  height: 240px; /* igual que tu max-height de .story-image */
}


@media screen and (min-width: 768px) {
  .carousel-container,
  .carousel-container .carousel-item {
    height: 400px !important;
  }
}


/* 2) Convierte la imagen en “cover” fullscreen dentro del contenedor */
.story-image {
  position: absolute !important;
  top: 50%; left: 50%;
  width: auto !important;
  height: auto !important;
  min-width: 100%;   /* cubre todo el ancho */
  min-height: 100%;  /* cubre toda la altura */
  object-fit: cover !important;
  transform: translate(-50%, -50%) scale(1);
  transform-origin: center center;
  animation: kenBurns 5s ease-in-out infinite alternate !important;
}

/* 3) Keyframes para zoom in–out suave */
@keyframes kenBurns {
  from { transform: translate(-50%, -50%) scale(1); }
  to   { transform: translate(-50%, -50%) scale(1.1); }
}

@keyframes kenBurnsZoom {
  from { transform: translate(-50%, -50%) scale(1); }
  to   { transform: translate(-50%, -50%) scale(1.2); }
}

@keyframes kenBurnsPanLeft {
  from { transform: translate(-40%, -50%) scale(1.1); }
  to   { transform: translate(-50%, -50%) scale(1);   }
}
/* — Pan desde la DERECHA: empieza escala 1.1 / 60% izquierda, acaba escala 1 / 50% centro — */
@keyframes kenBurnsPanRight {
  from { transform: translate(-40%, -50%) scale(1.1); }
  to   { transform: translate(-50%, -50%) scale(1);   }
}

    /* ============================ */
    /* Fin de la integración CSS    */
    /* ============================ */

.hand-hint {
  position: absolute;      /* lo hace “flotar” por encima de los hermanos */
  top: -70px;              /* sube el icono unos píxeles por encima del footer */
  left: 50%;               /* lo centra horizontalmente */
  transform: translateX(-50%);
  display: none;           /* lo mostraremos vía JS */
  pointer-events: none;    /* para que no interfiera con los clicks */
  animation: bounce 1s infinite;
  z-index: 10;             /* asegúrate de que esté por encima */
}

@keyframes bounce {
  0%, 100% { transform: translate(-50%, 0); }
  50%      { transform: translate(-50%, 10px); }
}




.level-label {
  display: inline-block;
  background-color: #3b82f6;    /* azul intenso */
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 600;
  margin-top: 4px;
}

/* Texto de info */
.story-info {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5db;               /* gris claro */
  line-height: 1.3;
}





.stories-filter-tabs {
  margin-top: 0.5rem;
  display: flex;
  flex-wrap: wrap;
  gap: 0.45rem;
  justify-content: center;
}

.no-topics {
  font-style: italic;
  color: #6b7280;
  text-align: center;
  margin-top: 300px;
}




/* ------------------------------------------ */
.game-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90%;
  max-width: 24rem;           /* aprox. 384px */
  padding: 1rem;
  background: var(--bg-popup, #2d2d2d);
  border: 1px solid var(--border-popup, #3d3d3d);
  border-radius: 0.75rem;     /* 12px */
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  color: var(--text-primary, #f0f0f0);
  display: flex;
  flex-direction: column;
  align-items: center;
  z-index: 1000;
}

/* Encabezado de popup (fragment y result) */
.game-popup .popup-header {
  font-size: 1.25rem;         /* 20px */
  font-weight: 600;
  margin-bottom: 0.75rem;     /* 12px */
  text-align: center;
  width: 100%;
}

/* Contenedor de botones dentro de cualquier popup */
.game-popup .popup-buttons {
  width: 100%;
  display: flex;
  justify-content: flex-end;
  margin-top: 0.5rem;
}





#fragmentPopup {
  width: 90%;
  max-width: 24rem;
  box-sizing: border-box;
  padding: 1rem;
  overflow: hidden; /* evita que el popup entero se desborde */
}

#fragmentPopup .fragment-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
  overflow-y: auto;
  overflow-x: hidden; /* ← fuerza a cortar scroll horizontal */
  width: 100%;
  box-sizing: border-box;
}

#fragmentPopup .fragment-options button {
  font-size: 1rem;
  padding: 12px 16px;
  background: linear-gradient(135deg, #27297d, #3a38e8);
  color: white;
  border: none;
  border-radius: 10px;
  text-align: center;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
  transition: transform 0.2s ease, background 0.3s ease;
  word-wrap: break-word;
  overflow-wrap: break-word;
  white-space: normal;
}

#fragmentPopup .fragment-options button:hover {
  transform: translateY(-2px);
  background: linear-gradient(135deg, #4f46e5, #7c3aed);
}

@media (max-width: 600px) {
  #fragmentPopup .fragment-options {
    padding: 0;
  }

  #fragmentPopup .fragment-options button {
    font-size: 1rem;
    padding: 14px;
  }
}



/* Estilos para vídeos en el carrusel: adaptar al mismo tamaño que las imágenes, pero sin animaciones */
.story-video {
  max-height: 250px;   /* igual que .story-image para escritorio */
  width: auto;
  object-fit: cover;
  border-radius: var(--radius-md);
  /* No incluir animation: kenBurns ... */
}

/* Responsividad igual que .story-image */
@media (max-width: 600px) {
  .story-video {
    max-height: 250px;
  }
}
@media screen and (min-width: 768px) {
  .carousel-container,
  .carousel-container .carousel-item {
    height: 400px !important; /* tu altura del carrusel */
  }
  .story-video {
    /* opcional: ajustar altura si difiere */
    max-height: 400px;
  }
}



.story-card.locked {
  opacity: 0.6;
  pointer-events: none;
  position: relative;
}

.story-card .lock-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.7);
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  font-weight: bold;
  z-index: 10;
}






/* Contenedor responsive */
/* Contenedor responsive */
#storiesFooter {
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0.4rem;
  background: #1f1f1f;
  /* Antes: flex-wrap: wrap; */
  flex-wrap: nowrap;         /* <-- forzamos una sola fila */
  gap: 0.5rem;
  overflow-x: auto;          /* permitir scroll horizontal si fuera necesario */
}

/* Botones flexibles y recortables */
#storiesFooter .btn-professional {
  flex: 1 1 0;               /* todos ocupan el mismo espacio y pueden encoger */
  min-width: 0;
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.4rem 0.2rem;
  text-decoration: none;
  font-size: 0.75rem;
  background: linear-gradient(135deg, var(--btn-active-start), var(--btn-active-end));
  border: 2px solid var(--btn-active-text);
  color: var(--btn-active-text);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  justify-content: center;
}

/* Icono fijo, no se encoge */
#storiesFooter .btn-professional i {
  font-size: 1.2rem;
  flex-shrink: 0;
}

/* Texto con recorte si hace falta */
#storiesFooter .btn-professional small {
  font-size: 0.65rem;
  line-height: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Ajustes extra en móviles muy estrechos */
@media (max-width: 360px) {
  #storiesFooter {
    padding: 0.3rem;
    gap: 0.25rem;
  }
  #storiesFooter .btn-professional {
    padding: 0.3rem 0.2rem;
    font-size: 0.7rem;
  }
  #storiesFooter .btn-professional i {
    font-size: 1rem;
  }
}





.memorytitle {
  margin: 0;                     /* quita márgenes por defecto */
  padding: 5px;
  text-align: center;
  border-bottom: 1px solid #444;
  display: flex;
  justify-content: center;       /* o space-between si vas a poner algo a los lados */
  align-items: center;
  font-size: 1.8rem;             /* ajusta según tu gusto */
  font-family: 'Orbitron', sans-serif;  /* si quieres mantener la misma tipografía */
  color: #fff;                   /* o el color que uses en tus headers */
}




/* === En pantallas de escritorio, centramos el footer al ancho del contenedor === */
@media screen and (min-width: 600px) {
  #storiesFooter {
    /* Que no exceda los 1400px de tu .stories-view */
    max-width: 1000px;
    /* Ancho al 100% del contenedor padre limitado por max-width */
    width: 100%;
    /* Con fixed, para centrarlo desplazamos su punto de referencia */
    left: 50%;
    transform: translateX(-50%);
  }
}










/* — Spinner mientras carga la imagen en el popup — */
.popup-image {
  position: relative;
  width: 150px;     /* ajústalo al tamaño deseado */
  height: 150px;    /* ajústalo al tamaño deseado */
  background: #000; /* fondo oscuro mientras carga */
  overflow: hidden;
}

.popup-image .spinner-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.7);
  z-index: 2;
}

.popup-image .spinner-overlay::after {
  content: "";
  width: 30px;
  height: 30px;
  border: 4px solid #fff;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.popup-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: none;  /* oculto hasta que cargue */
}




/* Toast bajo el header */
.toast {
  position: absolute;
  top: calc(100% + 70px);
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 6px 12px;
  border-radius: 4px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  z-index: 1001;
  opacity: 0;
  animation: fadeInOut 2s forwards;
}

@keyframes fadeInOut {
  0%   { opacity: 0; }
  10%  { opacity: 1; }
  90%  { opacity: 1; }
  100% { opacity: 0; }
}

/* Brillo momentáneo para el botón guardado */
.shine {
  animation: shineAnim 3s ease-in-out;
}

@keyframes shineAnim {
  0%, 100% { box-shadow: 0 0 5px #fff; transform: scale(1); }
  50%      { box-shadow: 0 0 15px #fff; transform: scale(1.1); }
}



/* ── ANIMACIÓN “HINT” PARA mainAudioButton ───────────────── */
.hint-shine {
  animation: shineAnim 2s ease-in-out infinite alternate;
  position: relative;
}
.hint-shine::after {
  content: "\f063";              /* código Font‑Awesome fa-arrow-down */
  font-family: "Font Awesome 5 Free";
  font-weight: 900;
  position: absolute;
  top: 110%;                     /* justo debajo del botón */
  left: 50%;
  transform: translateX(-50%);
  animation: bounce 1s ease-in-out infinite;
  font-size: 1.2rem;
  color: #fff;
}
@keyframes bounce {
  0%,100% { transform: translate(-50%, 0); }
  50%     { transform: translate(-50%, 10px); }
}






/* 1) Animación de cambio de gradiente */
@keyframes pulseColors {
  0% {
    background: linear-gradient(135deg, #ff005e, #ff7eb3);
  }
  25% {
    background: linear-gradient(135deg, #ff7eb3, #7afcff);
  }
  50% {
    background: linear-gradient(135deg, #7afcff, #00ff94);
  }
  75% {
    background: linear-gradient(135deg, #00ff94, #ffea00);
  }
  100% {
    background: linear-gradient(135deg, #ffea00, #ff005e);
  }
}

/* 2) Clase que combina brillo y cambio de colores */
.hint-color {
  animation:
    shineAnim 1.5s ease-in-out infinite alternate,
    pulseColors 4s ease-in-out infinite;
  /* Asegúrate de que tu botón use gradiente por defecto para que el cambio sea fluido */
  background: linear-gradient(135deg, #ff005e, #ff7eb3);
  color: #fff;
}




.memory-card {
  position: relative; /* Para que el glow se posicione respecto a cada carta */
  z-index: 1;         /* Base de las cartas */
}

@keyframes intense-glow {
  0%, 100% {
    box-shadow:
      0 0 8px 4px rgba(255, 215, 0, 0.8),
      0 0 20px 10px rgba(255, 215, 0, 0.6);
  }
  50% {
    box-shadow:
      0 0 20px 10px rgba(255, 255, 255, 1),
      0 0 40px 20px rgba(255, 215, 0, 0.8);
  }
}

.memory-card.matched-glow {
  animation: intense-glow 1s ease-in-out both;
  z-index: 100;       /* Que siempre quede sobre las demás cartas */
}










  /* CONTENEDOR permite overflow para las estrellas */
  .memory-cards-container {
    overflow: visible;
  }

  /* Overlay de estrellitas */
  .stars-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 200;
    overflow: visible;
  }
  .stars-overlay span {
    position: absolute;
    width: 8px; height: 8px;
    background: radial-gradient(circle, white 0%, gold 80%);
    border-radius: 50%;
    opacity: 0;
    animation: star-burst 1s ease-out forwards;
  }
  @keyframes star-burst {
    0%   { transform: translate(0,0) scale(0.5); opacity: 1; }
    80%  { opacity: 1; }
    100% { transform: translate(var(--dx), var(--dy)) scale(1); opacity: 0; }
  }

  /* MODAL de victoria */
  .victory-modal {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.5);
    background: rgba(0,0,0,0.85);
    color: #fff;
    padding: 2rem 3rem;
    border-radius: 1rem;
    text-align: center;
    font-size: 2rem;
    font-family: 'Arial Black', sans-serif;
    z-index: 300;
    opacity: 0;
    animation: modal-pop 0.6s forwards ease-out;
  }
  @keyframes modal-pop {
    to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }




* {
  cursor: url('/cursor/cursor4.png'), pointer !important;
}





/* Estilos para el modal */
.modal {
  display: none;              /* oculto por defecto */
  position: fixed;
  z-index: 10000;             /* por encima de todo */
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  justify-content: center;    /* centra horizontalmente */
  align-items: center;        /* centra verticalmente */
}
.modal-content {
  width: 80vw;
  height: 80vh;
  max-width: 1000px;
  max-height: 700px;
}


/* Ajustes solo en móvil (hasta 600px de ancho) */
@media (max-width: 600px) {
  .modal-content {
    width: 95vw;                      /* casi todo el ancho */
    height: auto;                     /* que se ajuste según contenido */
  }
  .modal-content iframe {
    width: 100%;                      /* llena el ancho */
    aspect-ratio: 16 / 9;             /* CSS moderno, mantiene 16:9 */
    height: auto;                     /* deja que aspect-ratio calcule */
  }}
/* Haz que el iframe siempre llene todo el contenedor */
.modal-content iframe {
  display: block;
  width: 100%;   /* ocupa todo el ancho del .modal-content */
  height: 100%;  /* ocupa toda la altura del .modal-content */
}
.close {
  position: absolute;
  top: 8px;
  right: 12px;
  font-size: 24px;
  font-weight: bold;
  color: #fff;
  cursor: pointer;
  z-index: 10001;
}
.close:hover {
  color: #ccc;
}




  </style>
  
  
  
</head>
<body>
  <!-- Loading Screen -->
  <div class="loading-screen">
    <div class="spinner"></div>
       <div class="loading-info">
     <small id="loadingText">Cargando… 0%</small>
  </div>
  </div>
  
  <!-- Stories List -->
  <section id="storiesList" class="stories-view" style="display: none;">
    <div class="stories-header">
      <h1>Interactive English Stories</h1>
      <p>Select a story to begin</p>

      <div class="stories-filter-tabs">
        <button data-level="" class="btn-professional active">Todos</button>
        <button data-level="fundamental" class="btn-professional">Fundamental</button>
        <button data-level="basico" class="btn-professional">Básico</button>
        <button data-level="intermedio" class="btn-professional">Intermedio</button>
        <button data-level="avanzado" class="btn-professional">Avanzado</button>
        <button data-level="otros" class="btn-professional">Otros</button>
      </div>
      <div id="noTopicsMessage" class="no-topics" style="display: none;">
        Aún no se agregaron temas
      </div>


    </div>
    <div class="stories-grid" id="storiesContainer"></div>



    <!-- Footer fijo sólo en la lista de historias -->
<footer id="storiesFooter" class="controls-footer">
  <a href="https://chat.whatsapp.com/FjsQxrL3qnu32P8mdZHY0C" class="btn-professional">
    <i class="fab fa-whatsapp fa-lg"></i>
    <small>Comunidad</small>
  </a>
  
  <button onclick="compartirEnFacebook()" class="btn-professional">
    <i class="fab fa-facebook-f fa-lg"></i>
    <small>Compartir</small>
  </button>

<a href="https://youtu.be/ujZtS_EEVgA"
   id="openYoutube"
   class="btn-professional">
  <i class="fab fa-youtube fa-lg"></i>
  <small>Tutorial</small>
</a>

 <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" class="inline-donate-form">
  <!-- Comando alojado -->
  <input type="hidden" name="cmd" value="_s-xclick" />
  <!-- Tu hosted_button_id -->
  <input type="hidden" name="hosted_button_id" value="NXEPDCBPD64S2" />
  <!-- Moneda -->
  <input type="hidden" name="currency_code" value="USD" />

  <!-- Aquí tu botón personalizado -->
  <button type="submit" class="btn-professional">
    <i class="fas fa-hand-holding-heart fa-lg"></i>
    <small>Donar</small>
  </button>
</form>
</footer>





<!-- Modal de vídeo YouTube -->
<div id="youtubeModal" class="modal">
  <div class="modal-content">
    <span id="closeModal" class="close">&times;</span>
    <iframe
      id="youtubeEmbed"
      width="560"
      height="315"
      src="https://youtu.be/ujZtS_EEVgA"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen>
    </iframe>
  </div>
</div>



  </section>
  
  <!-- Story View -->
  <main id="storyView" class="story-view" style="display: none;">
    <header class="story-header">
      <div class="header-left">
        <button id="backToStoriesButton"><i class="fas fa-arrow-left"></i></button>
        
      </div>
      <div class="header-content">
        <div class="header-title" id="storyTitle">
          Este es un título muy largo que se mostrará en varias líneas sin recorte 
        </div>


    



        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress" id="progressBar"></div>
            <span class="progress-text" id="progressText">0 de 0</span>
          </div>
        </div>

     
        
        <div class="header-right">
            <!-- Dropdown de velocidad del speech -->

            <div class="select-wrapper">
              <i class="fas fa-microphone voice-icon"></i>
              <select id="globalVoiceSelect" class="custom-select">
                <option value="m" selected>Voz hombre</option>
                <option value="w">Voz mujer</option>
              </select>
            </div>
            
            <div class="select-wrapper">
              <i class="fas fa-tachometer-alt speed-icon"></i>
              <select id="speedSelect" class="custom-select">
                <option value="0.5">Lento</option>
                <option value="0.9" selected>Normal</option>
                <option value="1.2">Rápido</option>
              </select>
            </div>
          <button id="playBtn" class="play-btn">
            <i class="fas fa-gamepad"></i> Play
          </button>
          <button id="savedListBtn" class="saved-list-btn">
            <i class="fas fa-list"></i><span id="savedCount">0</span>
          </button>
        </div>
      </div>
    </header>
    <div class="story-content">
      <div class="text-cards-container" id="textCardsContainer"></div>
    </div>
    <div class="controls-footer">

      <div id="firstTimeHint" class="hand-hint">
        <i class="fas fa-hand-point-down fa-3x"></i>
      </div>

      <button id="prevCardBtn" class="control-btn"><i class="fas fa-chevron-left"></i></button>
      <button id="mainAudioButton" class="control-btn"><i class="fas fa-play"></i></button>

      <button id="stopAudioButton" class="control-btn">
    <i class="fas fa-stop"></i>
  </button>

      <button id="recordButton" class="control-btn">
        <i class="fas fa-microphone"></i>
      </button>

 


<div id="fragmentPopup" class="game-popup" style="display: none; z-index: 1000;">
  <!-- 1. Encabezado -->
  <h2 class="popup-header">Selecciona un fragmento para practicar speaking</h2>

  <!-- 2. Opciones de fragmento -->
  <div id="fragmentOptions" class="fragment-options"></div>

  <!-- 3. Estado y temporizador -->
  <div id="status" class="popup-status">Listo para grabar</div>
  <div id="timer" class="popup-timer">00:00</div>

  <!-- 4. Botones -->
  <div class="popup-buttons">
    <button id="cancelPopup" class="btn-professional">Cancelar</button>
  </div>
</div>


<!-- Popup para resultados -->
<div id="resultPopup" class="game-popup" style="display: none; z-index: 1001;">
  <!-- 1. Encabezado -->
  <h2 class="popup-header">Resultado de Pronunciación</h2>

  <!-- 2. Contenido de los resultados -->
  <div id="resultContent"></div>

  <!-- 3. Botones de acción -->
  <div class="popup-buttons">
    <button id="closeResult" class="btn-professional">Cerrar</button>
  </div>
</div>



      <button id="nextCardBtn" class="control-btn"><i class="fas fa-chevron-right"></i></button>
</div>
  </main>
  
  <!-- Game View -->
  <div id="gameView">
    <button class="exit-game" id="exitGameBtn">Salir</button>
    <div id="gameContent"></div>
  </div>
  


  <script>



document.addEventListener('DOMContentLoaded', function() {
  const openBtn    = document.getElementById('openYoutube');
  const modal      = document.getElementById('youtubeModal');
  const closeBtn   = document.getElementById('closeModal');
  const embedFrame = document.getElementById('youtubeEmbed');

  function toEmbedURL(url) {
    const m = url.match(/(?:youtu\.be\/|v=)([A-Za-z0-9_-]{11})/);
    return m
      ? 'https://www.youtube.com/embed/' + m[1] + '?autoplay=1'
      : '';
  }

  openBtn.addEventListener('click', function(e) {
    e.preventDefault();
    embedFrame.src = toEmbedURL(this.href);
    modal.style.display = 'flex';
  });

  closeBtn.addEventListener('click', function() {
    modal.style.display = 'none';
    embedFrame.src = '';
  });

  window.addEventListener('click', function(e) {
    if (e.target === modal) {
      modal.style.display = 'none';
      embedFrame.src = '';
    }
  });
});



const congratsSound = new Audio('sounds/congrat.flac');
const victorySound = new Audio('sounds/congrat2.wav');

const doneSound = new Audio('sounds/done.mp3');
doneSound.preload = 'auto';


/**
 * Crea una ráfaga de estrellitas animadas sobre un container.
 * @param {HTMLElement} container - El elemento donde se superpondrán las estrellas.
 * @param {number} count - Número de estrellas a disparar.
 */
// 2) Función helper para las estrellitas
function burstStars(container, count = 20) {
  const overlay = document.createElement('div');
  overlay.className = 'stars-overlay';
  container.appendChild(overlay);

  for (let i = 0; i < count; i++) {
    const star = document.createElement('span');
    star.style.left = '50%';
    star.style.top  = '50%';
    const dx = (Math.random() - 0.5) * 200 + 'px';
    const dy = (Math.random() - 0.5) * 200 + 'px';
    star.style.setProperty('--dx', dx);
    star.style.setProperty('--dy', dy);
    overlay.appendChild(star);
  }
  setTimeout(() => {
    if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
  }, 1000);
}



function compartirEnFacebook() {
  // URL de la página que quieres compartir
  const pageUrl = encodeURIComponent(window.location.href);
  // Abre la ventana de diálogo de Facebook
  const fbShareUrl = 
    'https://www.facebook.com/sharer/sharer.php?u=' + pageUrl;
  
  window.open(
    fbShareUrl,
    'CompartirEnFacebook',
    'width=600,height=400,menubar=no,toolbar=no,resizable=yes'
  );
}

// — Polyfill para navigator.mediaDevices.getUserMedia —
// Secure contexts (HTTPS/localhost) son obligatorios :contentReference[oaicite:0]{index=0}
if (navigator.mediaDevices === undefined) {
  navigator.mediaDevices = {};
}

// Si no existe getUserMedia, lo creamos usando los prefijos más viejos :contentReference[oaicite:1]{index=1}
if (navigator.mediaDevices.getUserMedia === undefined) {
  navigator.mediaDevices.getUserMedia = function(constraints) {
    const legacy = navigator.getUserMedia ||
                   navigator.webkitGetUserMedia ||
                   navigator.mozGetUserMedia ||
                   navigator.msGetUserMedia;
    if (!legacy) {
      return Promise.reject(new Error('getUserMedia no implementado'));
    }
    return new Promise((resolve, reject) => {
      legacy.call(navigator, constraints, resolve, reject);
    });
  };
}



const API_BASE                 = 'https://mi-worker.saturninocok.workers.dev'
const STORIES_LIST_URL         = `${API_BASE}/stories`
const STORY_DATA_URL           = id => `${API_BASE}/stories/${id}`
const STORY_TRANSLATION_URL    = id => `${API_BASE}/stories/${id}/translation`


const PEXELS_BASE = 'https://px.saturninocok.workers.dev';
    

 // ─── 1) Constantes globales ─────────────────────────
  const SAMPLE_RATE = 16000;
  const PHON_WEIGHT  = 0.7;
  const CONF_WEIGHT  = 0.3;
const TIME_PER_WORD = 800;   // <--- aquí: ms de grabación por palabra
let silenceStart = null;      // timestamp de cuando empezó el silencio
const SILENCE_THRESHOLD = 0.01; // umbral RMS por debajo del cual consideramos silencio
const SILENCE_TIMEOUT   = 800;  // ms de silencio continuo para darlo por final


  // ─── 3) Helpers globales ────────────────────────────
function toFloat32(int16) {
  if (!int16 || !int16.length) {
    // devolvemos un array vacío para no romper nada
    return new Float32Array(0);
  }
  const f32 = new Float32Array(int16.length);
  for (let i = 0; i < int16.length; i++) {
    f32[i] = int16[i] / 32767;
  }
  return f32;
}


  function extractMFCCSequence(buffer) {
    const frameSize = 512, frames = [];
    for (let i = 0; i + frameSize <= buffer.length; i += frameSize) {
      const mfcc = Meyda.extract('mfcc', buffer.subarray(i, i + frameSize), {
        bufferSize: frameSize,
        sampleRate: SAMPLE_RATE,
        numberOfMFCCCoefficients: 13
      });
      if (mfcc) frames.push(mfcc);
    }
    return frames;
  }

  function dtwMultivariate(A, B) {
    const n = A.length, m = B.length, INF = 1e9;
    const D = Array(n+1).fill().map(() => Array(m+1).fill(INF));
    D[0][0] = 0;
    const euclid = (a, b) =>
      Math.sqrt(a.reduce((s, x, i) => s + (x - b[i])**2, 0));
    for (let i = 1; i <= n; i++) {
      for (let j = 1; j <= m; j++) {
        const cost = euclid(A[i-1], B[j-1]);
        D[i][j] = cost + Math.min(D[i-1][j], D[i][j-1], D[i-1][j-1]);
      }
    }
    return D[n][m] / (n + m);
  }

  function levenshtein(a, b) {
    const dp = Array(b.length+1).fill().map((_, i) => i);
    for (let i = 1; i <= a.length; i++) {
      let prev = i;
      for (let j = 1; j <= b.length; j++) {
        const cur = dp[j];
        dp[j] = a[i-1] === b[j-1]
          ? prev
          : 1 + Math.min(prev, dp[j-1], dp[j]);
        prev = cur;
      }
    }
    return dp[b.length];
  }

  function getFragments(text) {
    return text.match(/[^,.]+[,.]/g)?.map(s => s.trim()) || [];
  }


  // en ámbito global
let isRecording = false;
let hasResults  = false;
let lastResult  = null;
let selectedFragment = '';
let mediaRecorder, audioChunks = [];
let isProcessing = false;
let hasSpoken = false;

  // NUEVAS variables para temporizador y estado
  const statusEl = document.getElementById('status');
  const timerEl  = document.getElementById('timer');
  let recordStart = 0;
  let minRecordTime = 0;       // ya lo calculas en tu lógica
  let recordInterval = null;


  let audioCtx;
let sourceNode;
let processorNode;


  function setStatus(text) {
    statusEl.textContent = text;
  }


(async () => {
  // Carga meSpeak
  meSpeak.loadConfig('mespeak/mespeak_config.json');
  await new Promise(r => meSpeak.loadVoice('mespeak/voices/en/en.json', r));

  // Carga Vosk
  model = await Vosk.createModel('model/downloaded.tar.gz');

  // Inicia tu app
  new StoryManager();
})();



    class StoryManager {
      constructor() {
        this.stories = [];
        this.currentStory = null;
        this.currentCardIndex = 0;
        this.cards = [];
        this.speech = null;
      
        this.isPlaying = false;
        this.currentHighlightTimeout = null;
        this.selectedLanguage = 'en-GB';
        this.selectedSpeed = '1';
        this.savedWords = [];
        this.savedSentences = [];
        // Variables para juegos
        this.game1Index = 0;
        this.orderingAnswer = [];
        this.currentTriviaIndex = 0;
        this.triviaScore = 0;
        this.currentFillIndex = 0;
        this.fillScore = 0;
        this.currentFillData = null;
        this.memoryFirstCard = null;
        this.memoryLock = false;
        this.memoryMatches = 0;
        this.memoryTotalPairs = 0;
        this.selectedGender = 'm';

        this.audio = null;                   // HTMLAudioElement para el audio pregrabado

    this.marks = [];                     // Array con los marks de tiempo
    this.wordTimeouts = [];   
    this.pausedTime = 0; 

        this.isSpeakingNow = false;


this.recordButton = document.getElementById('recordButton');


this.popup            = document.getElementById('fragmentPopup');
this.optionsContainer = document.getElementById('fragmentOptions');
this.cancelBtn        = document.getElementById('cancelPopup');

this.cancelBtn.addEventListener(
  'click',
  this.cancelFragmentPopup.bind(this)
);



this.recordButton.disabled = false;  // siempre activo para elegir fragmento


      // referencias DOM extra
this.resultPopup   = document.getElementById('resultPopup');
this.resultContent = document.getElementById('resultContent');
this.closeResult = document.getElementById('closeResult');

// Reemplaza tu listener antiguo por este:
this.closeResult.addEventListener(
  'click',
  this.closeResultPopup.bind(this)
);










        this.init();
      }








      loadGlobalVoices() {
    // 1) Cargo de localStorage (si ya había selección)
    const stored = localStorage.getItem('selectedGender');
    if (stored === 'm' || stored === 'w') {
      this.selectedGender = stored;
    }

    // 2) Apunto al <select> y le pongo el valor
    const sel = document.getElementById('globalVoiceSelect');
    if (sel) {
      sel.value = this.selectedGender;

  
    }
  }

      async init() {  
    // Cargar velocidad previa


     // ——— Mostrar spinner en el arranque y reiniciar porcentaje ———
   showSpinner();
   const totalInitSteps = 1;       // solo 1 paso: cargar lista de historias
  let   initStep       = 0;
  this.updateLoading(initStep, totalInitSteps);


    const storedSpeed = localStorage.getItem('selectedSpeed');
   
    


    if (storedSpeed) {
    this.selectedSpeed = storedSpeed;
    // ▷ Aquí le decimos al <select> que muestre la opción guardada
    const speedEl = document.getElementById('speedSelect');
    if (speedEl) speedEl.value = this.selectedSpeed;
  }


    document.getElementById('speedSelect')
  .addEventListener('change', async e => {
    // 1) Actualiza la velocidad
    this.selectedSpeed = e.target.value;
    localStorage.setItem('selectedSpeed', this.selectedSpeed);

    // 2) Para y limpia todo lo anterior
    this.stopSpeech();  // pausa audio, limpia timeouts y quita highlights :contentReference[oaicite:0]{index=0}&#8203;:contentReference[oaicite:1]{index=1}

    // 3) Ajusta el playbackRate del audio actual
    if (this.audio) {
      this.audio.playbackRate = parseFloat(this.selectedSpeed);
    }

    // 4) Vuelve a reproducir automáticamente la tarjeta actual
    this.playCurrentCardAudio();  // arranca desde el inicio de la frase activa y reprograme los highlights :contentReference[oaicite:2]{index=2}&#8203;:contentReference[oaicite:3]{index=3}
  });

  
    // ---- AQUÍ CAMBIO ----
    await this.loadStoriesList();     // reemplaza loadStories()
    this.updateLoading(++initStep, totalInitSteps);
    this.hideLoading();
    this.showStoriesList();
    this.setupEventListeners();
    this.loadGlobalVoices();


    document.querySelectorAll('.stories-filter-tabs button').forEach(btn => {
  btn.addEventListener('click', () => {
    // 4.1) Marcar activo
    document.querySelector('.stories-filter-tabs button.active')
      .classList.remove('active');
    btn.classList.add('active');

    // 4.2) Volver a renderizar con el nivel
    const level = btn.getAttribute('data-level');
    this.showStoriesList(level);
  });
});



  }
      
 
// — MÉTODOS NUEVOS —




closeResultPopup() {
  // 1) Ocultar el popup de resultados
  this.resultPopup.style.display = 'none';

  // 2) Parar timers y nodos de audio
  if (recordInterval) {
    clearInterval(recordInterval);
    recordInterval = null;
  }
  if (processorNode) {
    processorNode.disconnect(); processorNode = null;
  }
  if (sourceNode) {
    sourceNode.disconnect(); sourceNode = null;
  }
  if (audioCtx) {
    audioCtx.close(); audioCtx = null;
  }

  // 3) Reset de estado interno
  selectedFragment = '';
  lastResult       = null;
  audioChunks      = [];
  isRecording      = false;
  isProcessing     = false;
  hasResults       = false;
  silenceStart     = null;

  // 4) Restablecer UI global
  const timerEl = document.getElementById('timer');
  timerEl.textContent = '00:00';
  setStatus('Listo para grabar');

  // 5) Asegurar recordButton activo
  this.recordButton.disabled = false;
  this.recordButton.classList.remove('recording');

  // 6) Limpiar resaltados activos
  document.querySelectorAll('.highlight-word.active')
    .forEach(el => el.classList.remove('active'));

  // 7) Resetear popup de selección
  const fragmentPopup = this.popup;
  fragmentPopup.querySelector('.popup-header').textContent = 'Selecciona un fragmento para practicar speaking';
  this.optionsContainer.style.display = '';
  this.cancelBtn.style.display      = '';

  // 8) Reabrir popup de selección
  fragmentPopup.style.display = 'flex';
}


cancelFragmentPopup() {
  // 1) Ocultar popup de selección
  this.popup.style.display = 'none';

  // 2) Reset estado interno
  selectedFragment = '';
  isRecording     = false;
  isProcessing    = false;

  // 3) Limpiar resaltados activos
  document.querySelectorAll('.highlight-word.active')
    .forEach(el => el.classList.remove('active'));

  // 4) Restablecer UI de fragmentPopup
  this.popup.querySelector('.popup-header').textContent = 'Selecciona un fragmento para practicar speaking';
  this.optionsContainer.style.display = '';
  this.cancelBtn.style.display      = '';

  // 5) Reset timer y status
  const timerEl = document.getElementById('timer');
  timerEl.textContent = '00:00';
  setStatus('Listo para grabar');

  // 6) Asegurar recordButton activo
  this.recordButton.disabled = false;
  this.recordButton.classList.remove('recording');
}


// 1) Mostrar popup con fragmentos
showFragmentPopup() {
  const card = document.querySelector('.text-card.active .english-text');
   const statusEl = this.popup.querySelector('.popup-status');
  if (statusEl) statusEl.style.display = '';
  const timerEl  = this.popup.querySelector('.popup-timer');
  if (timerEl)   timerEl.style.display = '';

  if (!card) return alert('No hay tarjeta activa');
  const frags = getFragments(card.innerText);
  this.optionsContainer.innerHTML = '';
  frags.forEach((f, i) => {
    const btn = document.createElement('button');
    btn.textContent = `${i + 1}. ${f}`;
    btn.onclick = () => this.selectFragment(f, card);
    this.optionsContainer.appendChild(btn);
  });
  this.popup.style.display = 'flex';
}



// — Modo “Agregar fragmento”, sin grabar —
showSentenceFragmentPopup() {
  // 0) Abrir y resetear popup
  this.popup.style.display = 'flex';
  this.optionsContainer.innerHTML = '';
  this.cancelBtn.style.display = '';

  // 0.1) Ocultar elementos de grabación
  const statusEl = this.popup.querySelector('.popup-status');
  if (statusEl) statusEl.style.display = 'none';
  const timerEl  = this.popup.querySelector('.popup-timer');
  if (timerEl)   timerEl.style.display = 'none';

  // 1) Cabecera
  this.popup.querySelector('.popup-header')
      .textContent = 'Selecciona un fragmento para agregar a la lista y usarlo en las actividades';

  // 2) Generar botones de fragmentos
  const card = document.querySelector('.text-card.active .english-text');
  const frags = getFragments(card.innerText);
  frags.forEach((f, i) => {
    const btn = document.createElement('button');
    btn.textContent = `${i + 1}. ${f}`;
    btn.addEventListener('click', () => {
      if (!this.savedSentences.some(s => s.sentence === f)) {
        this.savedSentences.push({ sentence: f });
        document.getElementById('savedCount').textContent =
          this.savedSentences.length + this.savedWords.length;
      }
      this.popup.style.display = 'none';

      
      // Crear toast
      const toast = document.createElement('div');
      toast.className   = 'toast';                    // usa tus estilos .toast
      toast.textContent = 'Fragmento guardado';

      // Insertarlo junto al header
      const container = document.querySelector('.header-content');
      container.appendChild(toast);

      // Efecto brillo en el botón de lista guardados
      const savedBtn = document.getElementById('savedListBtn');

      doneSound.currentTime = 0;
doneSound.play();


      savedBtn.classList.add('shine');

      // Limpiar tras 2 s
      setTimeout(() => {
        toast.remove();
        savedBtn.classList.remove('shine');
      }, 2000);


    });
    this.optionsContainer.appendChild(btn);
  });


}

// 2) Usuario selecciona fragmento: resaltar y grabar
selectFragment(fragment, cardEl) {
  // 1. Guarda y resalta en la tarjeta
  selectedFragment = fragment;
  cardEl.innerHTML = cardEl.innerHTML.replace(
    fragment,
    `<span class="highlight-word active">${fragment}</span>`
  );

  // 2. Muestra el fragment en el header del popup
  const popupHeader = document.querySelector('#fragmentPopup .popup-header');
  popupHeader.textContent = fragment;

  // 3. Oculta las opciones y el botón cancelar (pero deja vivo el popup)
  this.optionsContainer.style.display = 'none';
  this.cancelBtn.style.display      = 'none';

  // 4. Resetea UI de timer y status
  const timerEl = document.getElementById('timer');
  timerEl.textContent = '00:00';
  setStatus('Listo para grabar');

  // 5. Asegura que el botón de grabar esté habilitado
  this.recordButton.disabled = false;

  // 6. Arranca la grabación inmediatamente
  this.startRecording();
}

// 3) Iniciar grabación con MediaRecorder
/**
 * Inicia la grabación de audio, arranca el cronómetro y habilita la detección
 * de silencio para detenerse automáticamente tras haber hablado y cumplido
 * el tiempo mínimo de grabación.
 */
async startRecording() {
  // 1) Solicitar acceso al micrófono y preparar MediaRecorder
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  mediaRecorder = new MediaRecorder(stream);
  audioChunks = [];
  mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
  mediaRecorder.start();

  // 2) Crear AudioContext, fuente y procesador para medir RMS (silencio)
  audioCtx      = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
  sourceNode    = audioCtx.createMediaStreamSource(stream);
  processorNode = audioCtx.createScriptProcessor(4096, 1, 1);

  // Reiniciar flags y tiempos
  hasSpoken    = false;
  silenceStart = null;
  recordStart  = Date.now();

  // Mostrar cronómetro y estado inicial
  timerEl.textContent = '00:00';
  setStatus('Grabando…');
  this.recordButton.classList.add('recording');
  isRecording = true;

  // 3) En cada bloque de audio calculamos RMS y actualizamos cronómetro
  processorNode.onaudioprocess = e => {
    const data = e.inputBuffer.getChannelData(0);
    let sumSq = 0;
    for (let i = 0; i < data.length; i++) sumSq += data[i] ** 2;
    const rms = Math.sqrt(sumSq / data.length);

    const now     = Date.now();
    const elapsed = now - recordStart;

    // 3.1) Detectar si el usuario ha hablado al menos una vez
    if (rms > SILENCE_THRESHOLD) {
      hasSpoken = true;
      silenceStart = null;
    }
    // 3.2) Si ya habló, contar silencio continuo
    else if (hasSpoken) {
      silenceStart = silenceStart || now;
      const silentTime = now - silenceStart;
      // Si hay silencio > SILENCE_TIMEOUT y cumplimos minRecordTime, detenemos
      if (silentTime > SILENCE_TIMEOUT && elapsed > minRecordTime) {
        processorNode.disconnect();
        sourceNode.disconnect();
        setStatus('Procesando…');
        this.stopRecordingAndProcess();
      }
    }

    // 3.3) Actualizar visual del cronómetro cada 200 ms
    if (!recordInterval) {
      recordInterval = setInterval(() => {
        const secTotal = Math.floor((Date.now() - recordStart) / 1000);
        const mins = Math.floor(secTotal / 60);
        const secs = secTotal % 60;
        timerEl.textContent =
          `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
      }, 200);
    }
  };

  // 4) Conectar nodos de audio
  sourceNode.connect(processorNode);
  processorNode.connect(audioCtx.destination);
}







// 4) Detener grabación, procesar localmente y enviar al Worker
// 3) Detener grabación y procesar localmente
stopRecordingAndProcess() {
  // 1) Bloquear el botón de grabar durante el proceso
  this.recordButton.disabled = true;

  // 2) Cancelar el cronómetro visual si está activo
  if (recordInterval) {
    clearInterval(recordInterval);
    recordInterval = null;
  }

  // 3) Calcular tiempo transcurrido y restante
  const elapsed   = Date.now() - recordStart;
  const remaining = minRecordTime - elapsed;

  if (remaining > 0) {
    // 4a) Aún no llegamos al mínimo: avisar y programar procesado al expirar
    setStatus(`Esperando… ${remaining} ms restantes`);
    setTimeout(() => {
      setStatus('Procesando…');
      this._finalizeRecording();
    }, remaining);
  } else {
    // 4b) Ya cumplimos el mínimo: procesar de inmediato
    setStatus('Procesando…');
    this._finalizeRecording();
  }
}





_finalizeRecording() {
  // 1) Detener cronómetro si sigue corriendo
  if (recordInterval) {
    clearInterval(recordInterval);
    recordInterval = null;
  }

  // 2) Asegurar desconexión de nodos de audio
  if (processorNode) {
    processorNode.disconnect();
    processorNode = null;
  }
  if (sourceNode) {
    sourceNode.disconnect();
    sourceNode = null;
  }
  if (audioCtx) {
    // opcional: cerrar contexto
    audioCtx.close();
    audioCtx = null;
  }

  // 3) Al parar el recorder, procesar resultados
  mediaRecorder.onstop = async () => {
    const result = await this.processLocalPronunciation();
    lastResult = result;
    hasResults = true;

    // Mostrar popup con el resultado
    this.showResultPopup(result);

    // Enviar al Worker
   

    // Restaurar UI
    isProcessing = false;
    isRecording = false;
    setStatus('Evaluación completada.');
    this.recordButton.disabled = false;
    this.recordButton.classList.remove('recording');
  };

  // 4) Detener grabación
  mediaRecorder.stop();
}


// 5) Procesar localmente con Vosk, MFCC, DTW y Levenshtein
  async processLocalPronunciation() {
    // 1) Une los blobs y decodifica a AudioBuffer (igual que antes)
    const blob = new Blob(audioChunks, { type: 'audio/webm' });
    const arrayBuffer = await blob.arrayBuffer();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: SAMPLE_RATE
    });
    const audioBuf = await audioCtx.decodeAudioData(arrayBuffer);
    const pcm = audioBuf.getChannelData(0);

    // 2) Vosk
    return new Promise(resolve => {
      const rec = new model.KaldiRecognizer(SAMPLE_RATE);
      rec.setWords(true);

      rec.on('result', evt => {
        const wordsInfo = Array.isArray(evt.result)
          ? evt.result
          : evt.result?.result;
        if (!Array.isArray(wordsInfo) || !wordsInfo.length) {
          return resolve({ score: 0, details: [] });
        }

        // — aquí PREPARAMOS las referencias MFCC por cada palabra —
const targets = selectedFragment
  .trim()
  .toLowerCase()
  .split(/\s+/)
  .map(w => w.replace(/[.,?!;:¡¿:;"]/g, ''));

        const refSeqs = targets.map(w => {
          const raw = meSpeak.speak(w, { rawdata: 'array' });
          return extractMFCCSequence(toFloat32(raw));
        });

        // — CAMBIO: usamos un bucle para manejar palabra a palabra —
        const scores = [];
        for (let idx = 0; idx < wordsInfo.length && idx < targets.length; idx++) {
          const wi = wordsInfo[idx];
          const target = targets[idx];
          
          // 3.1) Si la palabra reconocida es muy diferente, asigna 0–9 aleatorio
          if (levenshtein(wi.word, target) > 1) {
            scores.push(Math.floor(Math.random() * 10));
            continue;
          }

          // 3.2) Extraer el segmento PCM correspondiente
          const start = Math.floor(wi.start * SAMPLE_RATE);
          const end   = Math.floor(wi.end   * SAMPLE_RATE);
          const segment = pcm.slice(start, end);

          // 3.3) Extraer MFCC aplicando toFloat32
          const mfccSeq = extractMFCCSequence(toFloat32(segment));

          // 3.4) Calcular DTW y normalizar con divisor fijo 50
          const dist = dtwMultivariate(refSeqs[idx] || [], mfccSeq);
          const phon = Math.max(0, 1 - (dist / 50)) * 100;

          // 3.5) Obtener confidence de Vosk
          const confSc = (wi.conf ?? 0) * 100;

          // 3.6) Score final con pesos 0.7 / 0.3
          scores.push(Math.round(
            PHON_WEIGHT * phon +
            CONF_WEIGHT * confSc
          ));
        }

        // 4) Promedio
        const avg = scores.length
          ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length)
          : 0;

        resolve({ score: avg, details: scores });
      });

      rec.acceptWaveform(audioBuf);
    });
  }



// 6) Mostrar resultado de pronunciación
showPronunciationResult({ score, details }) {
  // Ejemplo simple: alert. Puedes personalizar tu UI aquí.
  alert(`Tu puntuación de pronunciación: ${score}%\nDetallado: [${details.join(', ')}]`);
}



showResultPopup({ score, details }) {
  // 1) Ocultar el popup de grabación totalmente
  document.getElementById('fragmentPopup').style.display = 'none';

  // 2) Limpiar y poblar el contenido de resultados
  this.resultContent.innerHTML = '';
  const words = selectedFragment.trim().split(/\s+/);
  words.forEach((w, i) => {
    const p = document.createElement('p');
    p.textContent = `${w} → ${details[i] ?? 0}%`;
    this.resultContent.appendChild(p);
  });
  const avg = document.createElement('div');
  avg.style.fontWeight = 'bold';
  avg.textContent = `Promedio: ${score}%`;
  this.resultContent.appendChild(avg);

  // 3) Mostrar el popup de resultados
  this.resultPopup.style.display = 'flex';
}



async loadStoriesList() {
  try {
    // ——— 1) Obtener datos y preparar array de historias ———
    const { data } = await axios.get(STORIES_LIST_URL);
    this.stories = data.stories || [];
    // Agregamos los tres capítulos bloqueados
    this.stories.push(
      { title: 'Encrypted Passions',            level: 'Basic',        info: 'LOCKED - SOON', locked: true },
      { title: 'Hearts Under Surveillance',      level: 'Intermediate', info: 'LOCKED - SOON', locked: true },
      { title: 'Whispers of the Shattered Moon', level: 'Advanced',     info: 'LOCKED - SOON', locked: true }
    );

    // ——— 2) Mostrar spinner y resetear porcentaje ———
    showSpinner();
    const container = document.getElementById('storiesContainer');
    container.innerHTML = '';
    const total   = this.stories.length;
    let   loaded  = 0;
    this.updateLoading(loaded, total);

    // ——— 3) Renderizar cada historia y actualizar porcentaje ———
    for (const s of this.stories) {
      // === TU LÓGICA ACTUAL DE CREAR Y AÑADIR LA TARJETA ===
      // Ejemplo genérico (ajústalo si tu markup es distinto):
      const card = document.createElement('div');
      card.className = 'story-card';
      card.innerHTML = `
        <h3>${s.title}</h3>
        <p>${s.level} — ${s.info}</p>
      `;
      container.appendChild(card);
      // ================================================

      // Actualiza el texto bajo el spinner
      this.updateLoading(++loaded, total);

      // Pequeña pausa para forzar repintado y que veas el % cambiar
      await new Promise(r => setTimeout(r, 0));
    }

    // (El ocultado del spinner ya lo hace init() tras llamar a loadStoriesList)
  }
  catch (err) {
    console.error('❌ [loadStoriesList] error:', err);
    // Aun así, oculta el spinner para no dejar la pantalla bloqueada
    hideLoading();
  }
}

async loadStoryDetail(id) {
  try {
    // 0) preparar contadores y mostrar spinner
    const totalSteps = 3;
    let   step       = 0;
    showSpinner();
    this.updateLoading(step, totalSteps);

    // ——— Paso 1: carga historia + traducción —————————————————————
    const [detailResp, transResp] = await Promise.all([
      axios.get(STORY_DATA_URL(id)),
      axios.get(STORY_TRANSLATION_URL(id))
    ]);
    this.updateLoading(++step, totalSteps);

    this.currentStory = {
      ...detailResp.data.story,
      translation: transResp.data.translation
    };

    // ——— Paso 2: carpeta “folder” —————————————————————————————
    const rawTitle     = this.currentStory.title.split('<')[0].trim();
    const folder       = encodeURIComponent(rawTitle);
    this.currentFolder = folder;

    // ——— Paso 3: helper estricto para status = 200 ——————————————————
    const exists200 = async url => {
      try {
        const resp = await axios.get(url, {
          // **solo aceptamos 200**, cualquier otro status lanza
          validateStatus: status => status === 200
        });
       
        return true;
      } catch (e) {
        // aquí cae con 404, 301, 500…
        console.warn(`❌ [MISSING] ${url}`);
        return false;
      }
    };

    // ——— Paso 4: comprueba para cada género ————————————————————————
    const genders   = ['m','w'];
    const available = [];
    for (const g of genders) {
      const base     = `data/${folder}/${g}`;
      const jsonUrl  = `${base}/marks.json`;
      const audioUrl = `${base}/speech.mp3`;

      const jsonOk  = await exists200(jsonUrl);
      const audioOk = await exists200(audioUrl);

    

      if (jsonOk && audioOk) available.push(g);
    }

    // ——— Paso 5: actualiza selectedGender si ya no existe ——————————
    if (!available.includes(this.selectedGender)) {
      this.selectedGender = available[0] || 'm';
    }

    // ——— Paso 6: reconstruye el <select> SOLO con lo disponible ——————
    const sel = document.getElementById('globalVoiceSelect');
    sel.innerHTML = '';
    available.forEach(g => {
      sel.add(new Option(
        g === 'm' ? 'Voz hombre' : 'Voz mujer',
        g,
        g === this.selectedGender,
        g === this.selectedGender
      ));
    });
    // fallback: si por algún motivo no hay ninguno
    if (available.length === 0) {
      ['m','w'].forEach(g => sel.add(new Option(
        g === 'm' ? 'Voz hombre' : 'Voz mujer',
        g
      )));
      this.selectedGender = sel.value;
    }

    // ——— Paso 7: carga marks y audio definitivo ————————————————
    const g = this.selectedGender;
    const marksUrl = `data/${folder}/${g}/marks.json`;
    const audioUrl = `data/${folder}/${g}/speech.mp3`;
    this.marks = (await axios.get(marksUrl)).data;
    this.audio = new Audio(audioUrl);
    this.audio.preload      = 'auto';
    this.audio.playbackRate = parseFloat(this.selectedSpeed);

    this.updateLoading(++step, totalSteps);

  
    // ——— NUEVO: busca y reproduce música de fondo si existe ——————————
const musicFolder = `data/${folder}/mus`;
const musicUrl    = `${musicFolder}/0.mp3`; // o el nombre fijo que uses
if (await exists200(musicUrl)) {
  this.bgMusic = new Audio(musicUrl);
  this.bgMusic.loop   = true;
  this.bgMusic.volume = 0.2;  // volumen bajo
  this.bgMusic.play();
}
 this.updateLoading(++step, totalSteps);




  } catch (err) {
    console.error('🔥 Error en loadStoryDetail:', err);
  }
}


  /**
   * Actualiza el texto de carga con el porcentaje.
   * @param {number} loadedSteps – pasos completados
   * @param {number} totalSteps  – pasos totales
   */
  updateLoading(loadedSteps, totalSteps) {
    const pct = Math.floor((loadedSteps / totalSteps) * 100);
    const el  = document.getElementById('loadingText');
    if (el) el.textContent = `Cargando… ${pct}%`;
  }
      
      hideLoading() { document.querySelector('.loading-screen').style.display = 'none'; }
      
      showStoriesList(filterLevel = '') {
  // 1) Referencia al contenedor y lo limpiamos
  const container = document.getElementById('storiesContainer');
  container.innerHTML = '';

  // 2) Filtramos según el nivel (si filterLevel es cadena vacía, no filtramos)
  const filtered = filterLevel
    ? this.stories.filter(s => s.level.toLowerCase() === filterLevel)
    : this.stories;

  // 3) Mostramos/u ocultamos el mensaje si no hay resultados
  const msg = document.getElementById('noTopicsMessage');
  if (filtered.length === 0) {
    msg.style.display = 'block';
  } else {
    msg.style.display = 'none';

    // 4) Recorremos solo las historias filtradas y creamos cada tarjeta
    filtered.forEach((story, index) => {
      // Extraemos título inglés y traducción española
      const eng = story.title.split('<')[0].trim();
      const spa = (story.title.split('<')[1] || '')
        .replace('>', '')
        .trim();

      // Calculamos la ruta de la imagen de portada
      const folder     = encodeURIComponent(eng);
      const localCover = `data/${folder}/img/0.jpg`;
      const fallback   = story.titleImage
        || 'https://via.placeholder.com/100?text=No+Image';

      // Creamos el elemento tarjeta
    const card = document.createElement('div');
  // Si está bloqueada, añadimos la clase 'locked'
  card.className = 'story-card' + (story.locked ? ' locked' : '');

  card.innerHTML = `
    <div class="story-card-inner">
      <div class="story-card-image">
        <img
          src="data/${encodeURIComponent(story.title.split('<')[0].trim())}/img/0.jpg"
          onerror="this.onerror=null;this.src='${story.titleImage || 'https://via.placeholder.com/100?text=No+Image'}';"
          alt="${story.title}"
        >
      </div>
      <div class="story-card-text">
        <h3>${story.title.split('<')[0].trim()}</h3>
        ${story.title.includes('<') 
           ? `<p class="story-title-translation">${story.title.split('<')[1].replace('>','').trim()}</p>`
           : ''
        }
        <span class="level-label">${story.level}</span>
        <p class="story-info">${story.info}</p>
      </div>
      ${ story.locked 
         ? `<div class="lock-overlay">Locked – Soon</div>` 
         : ''
      }
    </div>
  `;

  // Solo habilitamos clic en no-bloqueadas
  if (!story.locked) {
    card.addEventListener('click', () => {
    // ▶️ sonido al escoger historia en la lista
    doneSound.currentTime = 0;
    doneSound.play();
    // ▶️ abrir la historia
    this.showStory(index);
  });
  }

  container.appendChild(card);
});
  }

  // 5) Asegurarnos de que la sección de lista esté visible
  document.getElementById('storiesList').style.display = 'block';
}




      
async showStory(storyIndex) {
 
  this.currentIndex = storyIndex; 

  // ↓↓ AÑADE ESTO para limpiar cualquier estado de pausa/resume
  this.pausedTime = 0;
  this.resumeSentenceIndex = null;
  this.isPlaying = false;
  // y opcionalmente restaurar el icono a “play”
  const mainIcon = document.getElementById('mainAudioButton').querySelector('i');
  if (mainIcon) mainIcon.classList.replace('fa-pause','fa-play');

  // Cargar datos de la historia seleccionada
  await this.loadStoryDetail(storyIndex);

  // Pasar a la vista
  document.getElementById('storiesList').style.display = 'none';
  document.getElementById('storyView').style.display   = 'block';
  document.getElementById('storyTitle').textContent    =
    this.currentStory.title.split('<')[0].trim();

  // Renderizar tarjetas e imágenes
  await this.renderStoryCards();

  hideSpinner();
  this.showHint();  


  // ── AÑADIMOS aquí la animación hint para el botón Play ──
const mainBtn = document.getElementById('mainAudioButton');
mainBtn.classList.add('hint-shine', 'hint-color')
mainBtn.addEventListener('click', function _removeHint() {
 mainBtn.classList.remove('hint-shine', 'hint-color');
  
  mainBtn.removeEventListener('click', _removeHint);
});



// —————— REEMPLAZA SI EXISTE antes tu listener de Stop ——————




}
      
      normalizeTranslationKeys() {
        const norm = {};
        for (const key in this.currentStory.translation) {
          norm[key.toLowerCase()] = this.currentStory.translation[key];
        }
        this.currentStory.translation = norm;
      }
      

      
    



      // Dentro de StoryManager
      playWordAudio(phrase) {
  if (!this.audio || !this.marks) return;
  const rate = this.audio.playbackRate || 1;
  const parts = phrase.toLowerCase().trim().split(/\s+/);

  // 1) Extraer sólo las marcas de la tarjeta actual
  const card = this.cards[this.currentCardIndex];
  const startIdx = parseInt(card.dataset.markStart, 10);
  const endIdx = this.cards[this.currentCardIndex + 1]
    ? parseInt(this.cards[this.currentCardIndex + 1].dataset.markStart, 10)
    : this.marks.length;
  const slice = this.marks.slice(startIdx, endIdx);

  // 2) Para cada palabra del phrase, escoger la aparición en slice que venga después de la anterior
  const found = [];
  let lastTime = -Infinity;
  for (const part of parts) {
    // Todas las ocurrencias de “part” en este slice, ordenadas por start
    const matches = slice
      .filter(m => m.word.toLowerCase() === part)
      .sort((a, b) => a.start - b.start);
    // Elegir la primera cuyo start > lastTime
    const pick = matches.find(m => m.start > lastTime);
    if (!pick) {
      console.warn(`❌ No se encontró "${part}" tras ${lastTime}s dentro de la tarjeta.`);
      return;
    }
    found.push(pick);
    lastTime = pick.start;
  }

  // 3) Calcular inicio y fin (restando pequeño offset según velocidad)
  const startTime = found[0].start;
  const rawEnd   = found[found.length - 1].end;
  let offset;
  if (rate < 1)        offset = 0.0;
  else if (rate === 1) offset = 0.0;
  else                 offset = 0.0;
  const endTime = Math.max(startTime, rawEnd - offset);
  const durationMs = ((endTime - startTime) * 1000) / rate + 50;

  // 4) Reproducir fragmento
  clearTimeout(this._wordTimeout);
  this.audio.pause();
  this.audio.currentTime = startTime;
  this.audio.play();
  this._wordTimeout = setTimeout(() => this.audio.pause(), durationMs);

 
}


// Actualiza el tamaño de fuente de los elementos .english-text según el valor global this.selectedSize.
updateEnglishTextFontSize() {
  const englishElements = document.querySelectorAll('.text-card .english-text');
  englishElements.forEach(el => {
    el.classList.remove('size1', 'size2', 'size3');
    if (this.selectedSize === "1") {
      el.classList.add('size1'); // font-size: 1.8rem
    } else if (this.selectedSize === "2") {
      el.classList.add('size2'); // font-size: 1.3rem
    } else if (this.selectedSize === "3") {
      el.classList.add('size3'); // font-size: 0.8rem
    }
  });
}

// Inicializa el carrusel para un contenedor dado.
initializeCarousel(carousel) {
  if (!carousel) return;
  let currentIndex = 0;
  const items = carousel.querySelectorAll('.carousel-item');
  const totalItems = items.length;
  if (totalItems === 0) return;
  
  const showItem = index => {
    items.forEach((item, i) => {
      if (i === index) item.classList.add('active');
      else item.classList.remove('active');
    });
  };
  
  // Auto-slider: cambia de imagen cada 5 segundos.
  let interval = setInterval(() => {
    currentIndex = (currentIndex + 1) % totalItems;
    showItem(currentIndex);
  }, 5000);
  
  // Botones manuales.
  const btnPrev = carousel.querySelector('.carousel-control.prev');
  const btnNext = carousel.querySelector('.carousel-control.next');
  if (btnPrev) {
    btnPrev.addEventListener('click', () => {
      clearInterval(interval);
      currentIndex = (currentIndex - 1 + totalItems) % totalItems;
      showItem(currentIndex);
      // Reinicia el intervalo.
      interval = setInterval(() => {
        currentIndex = (currentIndex + 1) % totalItems;
        showItem(currentIndex);
      }, 5000);
    });
  }
  if (btnNext) {
    btnNext.addEventListener('click', () => {
      clearInterval(interval);
      currentIndex = (currentIndex + 1) % totalItems;
      showItem(currentIndex);
      // Reinicia el intervalo.
      interval = setInterval(() => {
        currentIndex = (currentIndex + 1) % totalItems;
        showItem(currentIndex);
      }, 5000);
    });
  }
}

// Método que carga las imágenes de Pexels para cada imagen en el carrusel.
loadStoryImages() {
  document.querySelectorAll('.carousel-container img').forEach(img => {
    const query = img.getAttribute('data-image-query');
    // Si ya se cargó una URL en src (porque textObj.image era una URL), no hace nada.
    if (img.getAttribute('src') && (img.getAttribute('src').startsWith("http://") || img.getAttribute('src').startsWith("https://"))) {
      return;
    }
    if (query) {
      // Si el valor del query es en sí mismo una URL, se carga directamente.
      if (/^https?:\/\//i.test(query)) {
        img.src = query;
      } else {
      axios.get(
   `${PEXELS_BASE}/search?query=${encodeURIComponent(query)}&per_page=1`
 )
        .then(response => {
          if (response.data.photos && response.data.photos.length > 0) {
            const photo = response.data.photos[0];
            img.src = photo.src.medium;
          } else {
            img.src = `https://via.placeholder.com/600x250?text=${encodeURIComponent(query)}`;
          }
        })
        .catch(error => {
          console.error('Error loading image for', query, error);
          img.src = `https://via.placeholder.com/600x250?text=${encodeURIComponent(query)}`;
        });
      }
    }
  });
}

/* ------------------------------------------------------------------
   Método completo renderStoryCards() con asignación dinámica de imágenes
------------------------------------------------------------------*/
async renderStoryCards() {
  const container = document.getElementById('textCardsContainer');
  container.innerHTML = '';
  this.cards = [];
  this.currentCardIndex = 0;

  // 1) Preparo marcas para cada textObj
  const marksCopy = [...this.marks];
  this.currentStory.text.forEach(textObj => {
    const cleanWords = textObj.english
      .replace(/[.,¿?!'"“”‘’()]/g, '')
      .replace(/\s+/g, ' ')
      .trim()
      .split(' ');
    textObj.marks = marksCopy.splice(0, cleanWords.length);
  });

  // 2) Agrupo según el tamaño de tarjetas
  const groupSize = parseInt(this.selectedSize, 10) || 1;
  const grouped = [];
  for (let i = 0; i < this.currentStory.text.length; i += groupSize) {
    grouped.push(this.currentStory.text.slice(i, i + groupSize));
  }

  let globalIdx = 0;
  let paragraphIndex = 0;
  const folder = this.currentFolder;

  // Construyo mapa dinámico de imágenes nro → archivo
  const imgMap = await this.buildImgMap(folder);

  // 3) Construyo cada tarjeta
  for (const group of grouped) {
    let engHTML = '';
    let spaHTML = '';
    let imgsHTML = '';
    let imgCount = 0;
    const vocabMap = {};
    const vocabSet = new Set();

    // 3.1) Texto, imágenes y vocabulario
    group.forEach(obj => {
      engHTML += `<div>${this.addWordSpans(obj.english, obj.phrasal_verbs, obj.vocabulary)}</div>`;
      spaHTML += `<div>${obj.spanish}</div>`;

      paragraphIndex++;

      // Imagen o vídeo fallback + dinámico según imgMap
      const videoPath = `data/${folder}/vd/${paragraphIndex}.mp4`;
      const fileName = imgMap[String(paragraphIndex)];
      const imgLocal = fileName
        ? `data/${folder}/img/${fileName}`
        : `data/${folder}/img/${paragraphIndex}.jpg`;
      const isURL = /^https?:\/\//i.test(obj.image);

      imgsHTML += `
        <div class="carousel-item ${imgCount === 0 ? 'active' : ''}">
          <video
            src="${videoPath}"
            class="story-video"
            autoplay
            loop
            muted
            playsinline
            onerror="
              this.style.display='none';
              const imgEl = this.parentNode.querySelector('img');
              if (imgEl) imgEl.style.display = 'block';
            "
            style="display: block;"
          ></video>
          <img
            src="${imgLocal}"
            class="story-image"
            loading="lazy"
            style="display: none;"
            onerror="
              this.onerror = null;
              if ('${fileName}' === '') {
                this.src = '${obj.image}';
              }
              this.style.display = 'block';
            "
          >
        </div>`;
      imgCount++;

      // Vocabulario y phrasal verbs
      if (obj.vocabulary) {
        Object.entries(obj.vocabulary).forEach(([w, t]) => {
          vocabMap[w.toLowerCase()] = t;
          vocabSet.add(w.toLowerCase());
        });
      }
      if (obj.phrasal_verbs) {
        Object.entries(obj.phrasal_verbs).forEach(([pv, t]) => {
          vocabMap[pv.toLowerCase()] = t;
          vocabSet.add(pv.toLowerCase());
        });
      }
    });

    // 3.2) HTML del carrusel
    const carouselHTML = imgCount > 0
      ? `<div class="carousel-container"><div class="carousel-inner">${imgsHTML}</div></div>`
      : '';

    // 3.3) HTML de vocabulario
    const vocabHTML = vocabSet.size > 0
      ? `<div class="vocabulary-container">
           <p class="vocabulary-title">Vocabulary:</p>
           <button class="vocab-carousel-control left"><i class="fas fa-chevron-left"></i></button>
           <div class="vocabulary-words">
             ${[...vocabSet].map(w => `
               <div class="vocabulary-word" data-word="${w}" data-translation="${vocabMap[w]}">
                 <div class="vocabulary-image"><img src="" alt="${w}" loading="lazy"></div>
                 <div class="vocabulary-text"><strong>${w}</strong><span class="vocabulary-translation">${vocabMap[w]}</span></div>
               </div>`).join('')}
           </div>
           <button class="vocab-carousel-control right"><i class="fas fa-chevron-right"></i></button>
         </div>`
      : '';

    // 3.4) Creo y configuro la tarjeta
    const card = document.createElement('div');
    card.className = 'text-card';
    card.innerHTML = `
      ${carouselHTML}
      <div class="sentence-container">
        <div class="english-text">${engHTML}</div>
        <div class="full-translation">${spaHTML}</div>
        <div class="toggle-container">
          <button class="toggle-sentence-add btn-professional"><i class="fas fa-plus"></i>Fragmento a lista</button>
          <button class="toggle-word-translation btn-professional"><i class="fas fa-language"></i> Traducir Palabras</button>
        </div>
        ${vocabHTML}
      </div>`;

    card.dataset.markStart = globalIdx;
    const wordsCount = Array.from(card.querySelectorAll(
      '.english-text .highlight-word, .english-text .phrasal-verb-inline, .english-text .vocabulary-inline'
    )).length;
    globalIdx += wordsCount;

    container.appendChild(card);
    this.cards.push(card);

    // Eventos y carousel init
    const btnTranslate = card.querySelector('.toggle-word-translation');
    btnTranslate.addEventListener('click', () => {
      const showing = card.classList.toggle('show-translations');
      if (showing) {
        card.querySelectorAll('.english-text .highlight-word').forEach(span => {
          const key = span.dataset.word.toLowerCase();
          const tr = this.currentStory.translation[key];
          if (tr && !span.querySelector('.translation-tooltip')) {
            const tip = document.createElement('span');
            tip.className = 'translation-tooltip';
            tip.textContent = tr;
            span.appendChild(tip);
          }
        });
      } else {
        card.querySelectorAll('.translation-tooltip').forEach(tip => tip.remove());
      }
      btnTranslate.innerHTML = showing
        ? '<i class="fas fa-language"></i> Ocultar Traducciones'
        : '<i class="fas fa-language"></i> Traducir Palabras';
    });
   // Ahora abrimos el popup de selección de fragmentos en vez de guardar toda la frase
card.querySelector('.toggle-sentence-add').addEventListener('click', e => {
  e.stopPropagation();
  const anyWordPopup = document.querySelector('.word-popup');
  if (anyWordPopup) anyWordPopup.remove();
  this.showSentenceFragmentPopup();
});  // <–– ya no usamos once:true

    if (carouselHTML) this.initializeCarousel(card.querySelector('.carousel-container'));
  }

  // 4) Finalizo vista
  this.showCard(0);
  this.setupWordInteractions();
  this.loadVocabularyImages();
  this.loadStoryImages();
  this.updateEnglishTextFontSize();
  this.setupVocabularyCarousel();
}

/* ------------------------------------------------------------------
   Helper: buildImgMap(folder)
   Lee el directorio data/<folder>/img/ y mapea números a archivos
------------------------------------------------------------------*/
async buildImgMap(folder) {
  const res = await fetch(`data/${folder}/img/`);
  const html = await res.text();
  const regex = /href="([^"\?]+\.(?:jpe?g))"/gi;
  const map = {};
  let m;
  while ((m = regex.exec(html)) !== null) {
    const fileName = m[1];
    fileName
      .replace(/\.(?:jpe?g)$/i, '')
      .split(',')
      .map(n => n.trim())
      .filter(n => n)
      .forEach(n => { if (!map[n]) map[n] = fileName; });
  }
  return map;
}





showHint() {
  if (localStorage.getItem('hasSeenPlayHint')) return;
  const hint = document.getElementById('firstTimeHint');
  hint.style.display = 'block';
  setTimeout(() => hint.style.display = 'none', 3000);
  document.getElementById('mainAudioButton')
    .addEventListener('click', () => {
      hint.style.display = 'none';
      localStorage.setItem('hasSeenPlayHint', 'true');
    }, { once: true });
}


setupVocabularyCarousel() {
  document.querySelectorAll('.vocabulary-container').forEach(container => {
    const vocabWords = container.querySelector('.vocabulary-words');
    // Botones de control para scroll manual
    const leftBtn = container.querySelector('.vocab-carousel-control.left');
    const rightBtn = container.querySelector('.vocab-carousel-control.right');

    const images = vocabWords.querySelectorAll('img');
    let loadedCount = 0;
    let autoScrollInterval; // Variable para almacenar el intervalo del auto-scroll

    // Función que comprueba si se han cargado todas las imágenes y, en ese caso, inicia el auto-scroll.
    const maybeStart = () => {
      if (loadedCount === images.length) {
        startAutoScroll();
      }
    };

    // Verifica la carga de cada imagen y cuenta cuántas ya están cargadas.
    images.forEach(img => {
      if (img.complete) {
        loadedCount++;
      } else {
        img.addEventListener('load', () => {
          loadedCount++;
          maybeStart();
        });
      }
    });
    // Si todas ya están cargadas desde el inicio.
    maybeStart();

    // Listener para detener el auto-scroll si se hace click en el contenedor (o en alguno de sus descendientes)
    container.addEventListener('click', (e) => {
      if (autoScrollInterval) {
        clearInterval(autoScrollInterval);
        autoScrollInterval = null;
       
      }
    }, true); // fase de captura, para detectar antes que otros handlers

    // Listener específico para cada vocabulary-word
    vocabWords.querySelectorAll('.vocabulary-word').forEach(wordElem => {
      wordElem.addEventListener('click', (e) => {
        if (autoScrollInterval) {
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
         
        }
      });
    });

    // Listener para el botón izquierdo
    if (leftBtn) {
      leftBtn.addEventListener('click', (e) => {
        if (autoScrollInterval) {
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
        }
        // Ajusta el valor de desplazamiento (por ejemplo, -100 px) según tus necesidades
        vocabWords.scrollBy({ left: -100, behavior: 'smooth' });
      });
    }

    // Listener para el botón derecho
    if (rightBtn) {
      rightBtn.addEventListener('click', (e) => {
        if (autoScrollInterval) {
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
        }
        // Desplaza 100 px a la derecha, por ejemplo
        vocabWords.scrollBy({ left: 100, behavior: 'smooth' });
      });
    }

    // Función que inicia el auto-scroll.
    function startAutoScroll() {
      const checkBoundaries = () => {
        const buffer = 10;
        const left = vocabWords.scrollLeft;
        const client = vocabWords.clientWidth;
        const scroll = vocabWords.scrollWidth;
        const atStart = left <= buffer;
        const atEnd = left + client >= scroll - buffer;
        
        return { atStart, atEnd };
      };

      autoScrollInterval = setInterval(() => {
        const { atEnd } = checkBoundaries();
        if (atEnd) {
          // Si se alcanza el final, detener el auto-scroll.
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
       
        } else {
          vocabWords.scrollBy({ left: 1, behavior: 'auto' });
        }
      }, 30);
    }
  });
}






      getVocabularyForSentence(sentence, vocabList) {
        if (!vocabList) return [];
        const lowerSentence = sentence.toLowerCase();
        let detected = [];
        vocabList.forEach(phrase => {
          if (lowerSentence.includes(phrase)) {
            detected.push(phrase);
          }
        });
        return [...new Set(detected)];
      }
      
      addWordSpans(sentence, phrasalVerbs = {}, vocabObj = {}) {
  const words = sentence.split(/\s+/);
  let result = '';

  for (let i = 0; i < words.length; i++) {
    const raw = words[i];
    // limpio comillas, paréntesis y puntuación final
    const clean = raw.replace(/[.,¿?!'"“”‘’()]/g, '').toLowerCase();

    // 1) Caso especial sufijo ’s o 's:
    const apostropheMatch = raw.match(/^(.*?)([’']s)$/);
    if (apostropheMatch) {
      const [ , baseRaw, suffixRaw ] = apostropheMatch;
      const cleanBase = baseRaw.toLowerCase();
      const cleanSuffix = suffixRaw.toLowerCase();

      // Span para la parte base con posible tooltip
      const baseTooltip = vocabObj[cleanBase] || '';
      const baseClasses = 'highlight-word' + (baseTooltip ? ' vocabulary-inline' : '');
      result += `<span class="${baseClasses}" data-word="${cleanBase}"` +
                (baseTooltip ? ` data-translation="${baseTooltip}"` : '') +
                `>${baseRaw}` +
                (baseTooltip
                  ? `<span class="translation-tooltip">${baseTooltip}</span>`
                  : ''
                ) +
                `</span> `;

      // Span para el sufijo
      result += `<span class="highlight-word" data-word="${cleanSuffix}">${suffixRaw}</span> `;
      continue;
    }


    // 1a) Caso especial sufijo ’t o 't:
const apostropheTMatch = raw.match(/^(.*?)([’']t)$/);
if (apostropheTMatch) {
  const [ , baseRawT, suffixRawT ] = apostropheTMatch;
  const cleanBaseT  = baseRawT.toLowerCase();
  const cleanSuffixT = suffixRawT.toLowerCase();

  // Span para la parte base con posible tooltip
  const baseTooltipT = vocabObj[cleanBaseT] || '';
  const baseClassesT = 'highlight-word' + (baseTooltipT ? ' vocabulary-inline' : '');
  result += `<span class="${baseClassesT}" data-word="${cleanBaseT}"` +
            (baseTooltipT ? ` data-translation="${baseTooltipT}"` : '') +
            `>${baseRawT}` +
            (baseTooltipT
              ? `<span class="translation-tooltip">${baseTooltipT}</span>`
              : ''
            ) +
            `</span> `;

  // Span para el sufijo ’t/'t
  result += `<span class="highlight-word" data-word="${cleanSuffixT}">${suffixRawT}</span> `;
  continue;
}





    // 2) Phrasal verbs de dos palabras
    if (phrasalVerbs && i < words.length - 1) {
      const nextRaw = words[i + 1];
      const cleanNext = nextRaw.replace(/[.,¿?!'"“”‘’()]/g, '').toLowerCase();
      const two = `${clean} ${cleanNext}`;
      if (phrasalVerbs[two]) {
        const tooltip = phrasalVerbs[two];
        // Dos spans separados, cada uno resaltable
        result +=
          `<span class="highlight-word vocabulary-inline" data-word="${clean}" data-translation="${tooltip}">` +
            `${raw}<span class="translation-tooltip">${tooltip}</span>` +
          `</span> ` +
          `<span class="highlight-word vocabulary-inline" data-word="${cleanNext}" data-translation="${tooltip}">` +
            `${nextRaw}<span class="translation-tooltip">${tooltip}</span>` +
          `</span> `;
        i++;
        continue;
      }
    }

    // 3) Palabra normal o vocabulario
    let tooltip = '';
    let classes = 'highlight-word';
    if (vocabObj[clean]) {
      tooltip = vocabObj[clean];
      classes += ' vocabulary-inline';
    }

    result += `<span class="${classes}" data-word="${clean}"` +
              (tooltip ? ` data-translation="${tooltip}"` : '') +
              `>${raw}` +
              (tooltip
                ? `<span class="translation-tooltip">${tooltip}</span>`
                : ''
              ) +
              `</span> `;
  }

  return result.trim();
}

      
showCard(index) {
  // 1) Detener cualquier audio en curso
  if (this._wordTimeout) clearTimeout(this._wordTimeout);
  this.audio?.pause();

  // 2) Ocultar la tarjeta anterior
  const prev = this.cards[this.currentCardIndex];
  if (prev) prev.classList.remove('active');

  // 3) Actualizar índice y mostrar nueva tarjeta
  this.currentCardIndex = index;
  const card = this.cards[index];
  card.classList.add('active');

  // 4) Actualizar barra de progreso y texto
  const total  = this.cards.length;
  const current = index + 1;
  const pct     = (current / total) * 100;
  document.getElementById('progressBar').style.width  = `${pct}%`;
  document.getElementById('progressText').textContent = `${current} de ${total}`;

  // 5) Aplicar animación Ken Burns aleatoria a la imagen
  const img = card.querySelector('.story-image');
  if (img) {
    img.classList.remove('kb-zoom', 'kb-pan-left', 'kb-pan-right');
    const effects = ['kb-zoom', 'kb-pan-left', 'kb-pan-right'];
    img.classList.add(effects[Math.floor(Math.random() * effects.length)]);
  }

  // 6) Ajustar tamaño de fuente según preferencia
  this.updateEnglishTextFontSize();

  // 7) (Re)activar interacciones de palabras
  this.setupWordInteractions();
}




      updateProgress() {
  const total = this.cards.length;
  const current = this.currentCardIndex + 1;
  const progressPercentage = (current / total) * 100;
  document.getElementById('progressBar').style.width = progressPercentage + '%';
  document.getElementById('progressText').textContent = `${current} de ${total}`;
}
      
setupWordInteractions() { 
  // 1) Si había un handler previo, lo quitamos de la card anterior
  if (this._cardClickHandler && this._prevCard) {
    this._prevCard.removeEventListener('click', this._cardClickHandler);
  }

  // 2) Creamos un handler que escuche TODO click en la card
  const card = this.cards[this.currentCardIndex];
  const handler = e => {
    // Buscamos el elemento clicado más cercano que sea palabra o vocab
    const wordElem = e.target.closest(
      '.highlight-word, .phrasal-verb-inline, .vocabulary-inline, .vocabulary-word'
    );
    if (!wordElem || !card.contains(wordElem)) return;

    e.stopPropagation();
     this.stopSpeech();
    this.showWordPopup(wordElem);
  };

  // 3) Lo enganchamos a la card
  card.addEventListener('click', handler);

  // 4) Almacenamos referencias para poder limpiarlo la próxima vez
  this._cardClickHandler = handler;
  this._prevCard = card;
}


speakText(textToSpeak) {
  if (!textToSpeak) return;

  // Esperar hasta que speechSynthesis esté completamente inactivo
  const waitUntilFree = () => {
    if (!speechSynthesis.speaking && !speechSynthesis.pending) {
      const utterance = new SpeechSynthesisUtterance(textToSpeak);

      if (this.selectedVoice) {
        utterance.voice = this.selectedVoice;
      } else {
        utterance.lang = 'en-US';
      }

      utterance.rate = parseFloat(this.selectedSpeed) || 1;

      this.isSpeakingNow = true;

      utterance.addEventListener('end', () => {
        this.isSpeakingNow = false;
      });

      utterance.addEventListener('error', () => {
        this.isSpeakingNow = false;
      });

     
      speechSynthesis.speak(utterance);
    } else {
      // Esperar un poco más si aún está hablando
    
      setTimeout(waitUntilFree, 100);
    }
  };

  waitUntilFree(); // iniciar espera inteligente
}




showWordPopup(wordElement) {
  // 0) Detener audio principal y limpiar marcas (como antes)
  if (this.audio && !this.audio.paused) {
    this.stopSpeech(); // pausa audio, guarda this.pausedTime, limpia this.wordTimeouts
  }

  // 1) Remover cualquier popup existente
  const existingPopup = document.querySelector('.word-popup');
  if (existingPopup) {
    existingPopup.remove();
  }

  // 2) Obtener “clave” de la palabra
  const word = wordElement.getAttribute('data-word') || wordElement.textContent.trim();

  // 3) Primero intentamos leer data-translation; si no existe, buscamos en currentStory.translation
  let translation = wordElement.getAttribute('data-translation') || "";
  if (!translation && this.currentStory && this.currentStory.translation) {
    translation = this.currentStory.translation[word.toLowerCase()] || "";
  }

  // 4) Crear el popup
  const popup = document.createElement('div');
  popup.className = 'word-popup';
  popup.innerHTML = `
    <div class="popup-content">
      <h2>${word}</h2>
      <p>${translation}</p>
      <div class="popup-image"></div>
    <button class="popup-add btn-professional">Agregar</button>
    <button class="popup-listen btn-professional">Escuchar</button>
    <button class="popup-close btn-professional">Cerrar</button>
    </div>
  `;
  document.body.appendChild(popup);

  // 5) Reproducir sólo el fragmento de la palabra
  const wordText = word;
  this.playWordAudio(wordText);

  // 6) Cancelar cualquier speechSynthesis en curso
  window.speechSynthesis.cancel();
  if (this.isPlaying) {
    this.isPlaying = false;
    const mainBtnIcon = document.getElementById("mainAudioButton").querySelector("i");
    if (mainBtnIcon && mainBtnIcon.classList.contains("fa-pause")) {
      mainBtnIcon.classList.replace("fa-pause", "fa-play");
    }
  }

// 7) Cargar la imagen de Pexels con spinner
(() => {
  const imgDiv = popup.querySelector('.popup-image');

  // 7.1) Inserta spinner + elemento <img> oculto
  imgDiv.innerHTML = `
    <div class="spinner-overlay"></div>
    <img alt="${word}">
  `;
  const imgEl = imgDiv.querySelector('img');

  // 7.2) Cuando la <img> termine de cargar, quita el spinner y muestra la imagen
  imgEl.addEventListener('load', () => {
    const spinner = imgDiv.querySelector('.spinner-overlay');
    if (spinner) spinner.remove();
    imgEl.style.display = 'block';
  });

  // 7.3) Dispara la petición y asigna la URL al <img>
 axios.get(`${PEXELS_BASE}/search?query=${encodeURIComponent(word)}&per_page=1`)
  .then(response => {
    const photo = response.data.photos[0];
    // Asigna la versión "large" como predeterminada
    imgEl.src = photo.src.large;
    // Y la "large2x" para pantallas de alta densidad (Retina)
    imgEl.srcset = `${photo.src.large2x} 2x`;
  })
    .catch(error => {
      console.error("Error fetching image for word:", error);
      imgEl.src = `https://via.placeholder.com/150?text=${encodeURIComponent(word)}`;
    });
})();

  // 8) Listener único para “OK” (Cerrar): reanudar audio principal y marcas SOLO si quedó interrumpido
  popup.querySelector('.popup-close').addEventListener('click', e => {
    e.stopPropagation();

    // 8.1) Detener audio de la palabra
    if (this._wordTimeout) {
      clearTimeout(this._wordTimeout);
      this._wordTimeout = null;
    }
    if (this.wordAudio) {
      this.wordAudio.pause();
    }

    // 8.2) Eliminar popup
    popup.remove();

    // 8.3) Verificar si el audio principal estaba a mitad para reanudar
    if (this.audio) {
      const current = this.pausedTime || 0;
      const duration = this.audio.duration || 0;

      // Solo reanudar si pausedTime>0 y pausedTime<duration
      if (current > 0 && current < duration) {
        // Cambiar el ícono a “pausa” si hace falta
        const mainBtnIcon = document.getElementById("mainAudioButton").querySelector("i");
        if (mainBtnIcon && mainBtnIcon.classList.contains("fa-play")) {
          mainBtnIcon.classList.replace("fa-play", "fa-pause");
        }
        // Reanuda audio y marcas desde pausedTime
        this.playCurrentCardAudio();
      }
    }
  }, { once: true });

  // 9) Listener único para “Agregar” palabra a la lista de guardados
  popup.querySelector('.popup-add').addEventListener('click', e => {
  e.stopPropagation();
  if (!this.savedWords.some(item => item.word === word)) {
    // guardar palabra y actualizar contador
    this.savedWords.push({ word, translation });
    document.getElementById('savedCount').textContent =
      this.savedSentences.length + this.savedWords.length;

    // crear toast
    const toast = document.createElement('div');
    toast.className   = 'toast';
    toast.textContent = 'Palabra agregada';

    // insertarlo dentro de .header-content
    const container = document.querySelector('.header-content');
    container.appendChild(toast);

    // efecto brillo en el botón
    const savedBtn = document.getElementById('savedListBtn');

    doneSound.currentTime = 0;
doneSound.play();


    savedBtn.classList.add('shine');

    // limpiar tras 2 s
    setTimeout(() => {
      toast.remove();
      savedBtn.classList.remove('shine');
    }, 2000);
  }
  popup.remove();
}, { once: true });

  // 10) Listener único para “Escuchar”
popup.querySelector('.popup-listen').addEventListener('click', e => {
  e.stopPropagation();
  // Reutiliza exactamente el mismo fragmento que ya cargaste en this.audio + this.marks
  this.playWordAudio(word);
});

  // 10) Prevenir propagación de clicks hacia abajo
  popup.addEventListener('click', e => e.stopPropagation());
}









      showSavedListPopup() {
        const existingPopup = document.querySelector('.saved-list-popup');
        if (existingPopup) { existingPopup.remove(); }
        const popup = document.createElement('div');
        popup.className = 'saved-list-popup';
        let sentencesHTML = '';
        if (this.savedSentences.length > 0) {
          sentencesHTML = '<h3>Oraciones Guardadas</h3><ul>';
          this.savedSentences.forEach((item, index) => {
            sentencesHTML += `<li>
                                <span>${item.sentence}</span>
                                <button data-index="${index}" class="delete-sentence-btn btn-professional">Eliminar</button>
                              </li>`;
          });
          sentencesHTML += '</ul>';
        } else {
          sentencesHTML = '<p>No hay oraciones guardadas.</p>';
        }
        let vocabularyHTML = '';
        if (this.savedWords.length > 0) {
          vocabularyHTML = '<h3>Vocabulary Guardado</h3><ul>';
          this.savedWords.forEach((item, index) => {
            vocabularyHTML += `<li>
                                <span>${item.word} - ${item.translation}</span>
                                <button data-index="${index}" class="delete-word-btn btn-professional">Eliminar</button>
                              </li>`;
          });
          vocabularyHTML += '</ul>';
        } else {
          vocabularyHTML = '<p>No hay palabras guardadas.</p>';
        }
        popup.innerHTML = `
          <h2>Guardado</h2>
          ${sentencesHTML}
          ${vocabularyHTML}
          <div class="popup-buttons">
            <button class="popup-play-btn btn-professional">Practicar y Jugar</button>
            <button class="popup-close btn-professional">Cerrar</button>
          </div>
        `;
        document.body.appendChild(popup);
        popup.querySelectorAll('.delete-sentence-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const idx = parseInt(e.currentTarget.getAttribute('data-index'));
            this.savedSentences.splice(idx, 1);
            popup.remove();
            this.showSavedListPopup();
          });
        });
        popup.querySelectorAll('.delete-word-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const idx = parseInt(e.currentTarget.getAttribute('data-index'));
            this.savedWords.splice(idx, 1);
            document.getElementById('savedCount').textContent = this.savedSentences.length + this.savedWords.length;
            popup.remove();
            this.showSavedListPopup();
          });
        });
        popup.querySelector('.popup-close').addEventListener('click', (e) => {
          e.stopPropagation();
          popup.remove();
        }, { once: true });
        popup.querySelector('.popup-play-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          
 popup.remove();
            if (typeof this.stopSpeech === 'function') {
      this.stopSpeech();
    } else {
      window.speechSynthesis.cancel();
    }



    this.showGameSelectionPopup();


        });
        popup.addEventListener('click', (e) => e.stopPropagation());
      }
      

      playCurrentCardAudio() {
  // Limpia cualquier estado previo
  this.stopSpeech();

  const card = this.cards?.[this.currentCardIndex];
  if (!card) {
    console.warn("⚠️ No hay tarjeta actual para reproducir.");
    return;
  }

  const sentenceDivs = Array.from(card.querySelectorAll('.english-text > div'));
  const sentencesWords = sentenceDivs.map(div =>
    Array.from(div.querySelectorAll('.highlight-word, .phrasal-verb-inline, .vocabulary-inline'))
  );

  const markStartGlobal = parseInt(card.dataset.markStart, 10) || 0;
  let localIdx = 0;
  const sentenceMarks = sentencesWords.map(nodes => {
    const slice = this.marks.slice(markStartGlobal + localIdx, markStartGlobal + localIdx + nodes.length);
    localIdx += nodes.length;
    return slice;
  });

  const rate = parseFloat(this.selectedSpeed) || 1;
  if (!this.audio) {
    console.warn("⚠️ No hay audio cargado.");
    return;
  }
  this.audio.playbackRate = rate;

  const playSentence = (i) => {
    if (i >= sentenceMarks.length) {
      this.pausedTime = 0;
      this.resumeSentenceIndex = null;
      this.isPlaying = false;
      const iconEnd = document.getElementById('mainAudioButton')?.querySelector('i');
      if (iconEnd) iconEnd.classList.replace('fa-pause', 'fa-play');
      return;
    }

    const marksForSentence = sentenceMarks[i];
    if (!marksForSentence.length) return playSentence(i + 1);

    const startTime = marksForSentence[0].start;
    const endTime = marksForSentence[marksForSentence.length - 1].end;

    const actualStart = (this.resumeSentenceIndex === i)
      ? this.pausedTime
      : startTime;

    this.audio.currentTime = actualStart;
    this.audio.play();
    this.isPlaying = true;

    const iconPlay = document.getElementById('mainAudioButton')?.querySelector('i');
    if (iconPlay) iconPlay.classList.replace('fa-play', 'fa-pause');

    marksForSentence.forEach((m, idx) => {
      const highlightDelay = Math.max(0, (m.start - actualStart) / rate * 1000);
      const unhighlightDelay = Math.max(0, (m.end - actualStart) / rate * 1000);

      if (this.resumeSentenceIndex === i && m.end <= this.pausedTime) return;

      const hTO = setTimeout(() => sentencesWords[i][idx].classList.add('active'), highlightDelay);
      const uTO = setTimeout(() => sentencesWords[i][idx].classList.remove('active'), unhighlightDelay);
      this.wordTimeouts.push(hTO, uTO);
    });

    const phraseEndDelay = (endTime - actualStart) / rate * 1000;
    const endTO = setTimeout(() => {
      this.audio.pause();
      this.wordTimeouts.forEach(t => clearTimeout(t));
      this.wordTimeouts = [];
      sentencesWords[i].forEach(n => n.classList.remove('active'));
      playSentence(i + 1);
    }, phraseEndDelay);

    this.wordTimeouts.push(endTO);
  };

  if (this.pausedTime) {
    const idx = sentenceMarks.findIndex(marks => {
      if (!marks.length) return false;
      const s = marks[0].start, e = marks[marks.length - 1].end;
      return this.pausedTime >= s && this.pausedTime <= e;
    });
    this.resumeSentenceIndex = idx >= 0 ? idx : 0;
    playSentence(this.resumeSentenceIndex);
  } else {
    this.resumeSentenceIndex = null;
    playSentence(0);
  }
}





// Función que actualiza el tamaño de los elementos .english-text
updateEnglishTextFontSize() {
  // Busca todos los contenedores de texto en las tarjetas (ya renderizadas)
  const englishElements = document.querySelectorAll('.text-card .english-text');
  englishElements.forEach(el => {
    el.classList.remove('size1', 'size2', 'size3');
    if (this.selectedSize === "1") {
      el.classList.add('size1'); // font-size: 1.8rem
    } else if (this.selectedSize === "2") {
      el.classList.add('size2'); // font-size: 1.3rem
    } else if (this.selectedSize === "3") {
      el.classList.add('size3'); // font-size: 0.8rem
    }
  });
}



calculateExactWordDurations(text, voiceURI, rate) {
  const avgCharsPerSecond = 15;
  const words = text.split(' ');
  return words.map(word => {
    const wordLength = word.replace(/[^a-zA-Z]/g, '').length;
    const duration = (wordLength / avgCharsPerSecond) * 1000;
    return duration / rate;
  });
}













      showFullTranslation() {
        // Lógica adicional si se desea
      }
      
      stopSpeech() {
  if (this.audio && !this.audio.paused) {
    this.pausedTime = this.audio.currentTime;
  }
  // limpiamos audio
  if (this.audio) this.audio.pause();

  this.wordTimeouts.forEach(to => clearTimeout(to));
  this.wordTimeouts = [];

    const currentCard = this.cards?.[this.currentCardIndex];
  if (currentCard) {
    const activeSel = currentCard.querySelectorAll(
      '.highlight-word.active, .phrasal-verb-inline.active, .vocabulary-inline.active'
    );
    activeSel.forEach(n => n.classList.remove('active'));
  }

  this.isPlaying = false;
  const icon = document.getElementById('mainAudioButton').querySelector('i');
  if (icon) icon.classList.replace('fa-pause','fa-play');
}


resumeSpeech() {
  if (!this.audio) return;
  this.isPlaying = true;
  const icon = document.getElementById('mainAudioButton').querySelector('i');
  if (icon) icon.classList.replace('fa-play','fa-pause');
  // No limpiar pausedTime ni resumeSentenceIndex
  this.playCurrentCardAudio();
}

setupEventListeners() {
  // 0) Grabación / popup / procesado (toggle)
  this.recordButton = document.getElementById('recordButton');
  this.recordButton.addEventListener('click', () => {
    if (isProcessing) return;

    if (!selectedFragment && !isRecording) {
      // 1a) Sin fragmento: abrir popup de selección
      this.showFragmentPopup();
      setStatus('Selecciona un fragmento para practicar speaking');
    }
    else if (!isRecording) {
      // 1b) Fragmento elegido: arrancar grabación
      this.startRecording();
    }
    else {
      // 1c) Ya grabando: detener y procesar
      this.stopRecordingAndProcess();
    }
  });

  // 1) Botón principal de play/pause/resume para audio de la historia
const mainBtn = document.getElementById('mainAudioButton');
mainBtn.addEventListener('click', () => {
  // 0) Quitar SIEMPRE el brillo, así se limpia tanto al iniciar
  //    como si vienes tras un Stop
  mainBtn.classList.remove('hint-shine', 'hint-color');

  // 1) Control de reproducción
  if (this.isPlaying) {
    this.stopSpeech();
  } else if (this.audio && this.audio.currentTime > 0 && this.audio.currentTime < this.audio.duration) {
    this.resumeSpeech();
  } else {
    this.playCurrentCardAudio();
  }
});


    // NUEVO: listener para Stop
  const stopBtn = document.getElementById('stopAudioButton');
  stopBtn.addEventListener('click', () => {
    this.stopSpeech();
    this.pausedTime = 0;
    this.resumeSentenceIndex = null;
    const mainBtn = document.getElementById('mainAudioButton');
    mainBtn.classList.add('hint-shine', 'hint-color');
  });

  

// 2) Prev card
document.getElementById('prevCardBtn').addEventListener('click', () => {
  if (this.currentCardIndex > 0) {
    // 0) Quitamos el brillo, igual que si hubieras pulsado Play
    mainBtn.classList.remove('hint-shine', 'hint-color');

    this.stopSpeech();
    this.pausedTime = 0;
    this.resumeSentenceIndex = null;
    this.showCard(this.currentCardIndex - 1);

    // 1) Reproducir la nueva carta
    this.playCurrentCardAudio();
  }
  setTimeout(() => this.setupVocabularyCarousel(), 200);
});

// 3) Next card
document.getElementById('nextCardBtn').addEventListener('click', () => {
  if (this.currentCardIndex < this.cards.length - 1) {
    // 0) Quitamos el brillo
    mainBtn.classList.remove('hint-shine', 'hint-color');

    this.stopSpeech();
    this.pausedTime = 0;
    this.resumeSentenceIndex = null;
    this.showCard(this.currentCardIndex + 1);

    // 1) Reproducir la nueva carta
    this.playCurrentCardAudio();
  }
  setTimeout(() => this.setupVocabularyCarousel(), 200);
});


  // 4) Back to stories
document.getElementById('backToStoriesButton').addEventListener('click', () => {

   doneSound.currentTime = 0;
  doneSound.play();
  
  // 1) Si hay algún fragmentPopup abierto, cancelarlo (oculta y limpia estado)
  this.cancelFragmentPopup();

  // 2) Si hay un word-popup en pantalla, eliminarlo del DOM
  const anyWordPopup = document.querySelector('.word-popup');
  if (anyWordPopup) {
    anyWordPopup.remove();
  }

  // 3) Detener audio principal y limpiar marcas
  this.stopSpeech();
   if (this.bgMusic) this.bgMusic.pause();

  // 4) Asegurarse de detener también cualquier audio corto de palabra
  if (this._wordTimeout) {
    clearTimeout(this._wordTimeout);
    this._wordTimeout = null;
  }
  if (this.wordAudio) {
    this.wordAudio.pause();
  }

  // 5) Ocultar vista de story y mostrar lista
  document.getElementById('storyView').style.display = 'none';
  document.getElementById('storiesList').style.display = 'block';
});

  // 5) Saved list popup
  document.getElementById('savedListBtn').addEventListener('click', () => {
    doneSound.currentTime = 0;
  doneSound.play();
  
    this.showSavedListPopup();
  });

  // 6) Iniciar juego
document.getElementById('playBtn').addEventListener('click', () => {

   doneSound.currentTime = 0;
  doneSound.play();

    // 1) Detener cualquier narración en curso
  if (typeof this.stopSpeech === 'function') {
    this.stopSpeech();
  } else {
    // Fallback si no tuvieras stopSpeech()
    window.speechSynthesis.cancel();
  }


  if (!this.currentStory || !Array.isArray(this.currentStory.games)) {
    // Si no hay historia cargada o no hay juegos definidos, no hacemos nada
    console.warn("No hay ninguna historia activa o no se cargaron los juegos.");
    return;
  }
  this.showGameSelectionPopup();
});

  // 7) Salir de juego
  document.getElementById('exitGameBtn').addEventListener('click', () => {
      doneSound.currentTime = 0;
  doneSound.play();
    this.exitGame();
  });

  // 8) Cambio de voz global
  document.getElementById('globalVoiceSelect').addEventListener('change', async e => {
    this.selectedGender = e.target.value;
    localStorage.setItem('selectedGender', this.selectedGender);
    if (this.currentIndex == null) return;
    this.stopSpeech();
    await this.loadStoryDetail(this.currentIndex);
    this.playCurrentCardAudio();
  });

  // 9) Ajuste de tamaño de fuente al redimensionar ventana
  window.addEventListener('resize', () => {
    if (document.getElementById('game3Container')) {
      this.resizeMemoryCardsGrid();
    }
  });

  // 10) Cerrar popup de resultados y reset UI
  this.closeResult = document.getElementById('closeResult');
  this.closeResult.addEventListener(
    'click',
    this.closeResultPopup.bind(this)
  );
}

      
      
      loadVocabularyImages() {
        document.querySelectorAll('.vocabulary-image img').forEach(el => {
          const word = el.getAttribute('alt').trim();
          axios.get(
  `${PEXELS_BASE}/search?query=${encodeURIComponent(word)}&per_page=1`
)
            .then(response => {
              if(response.data.photos && response.data.photos.length > 0) {
                const photo = response.data.photos[0];
                el.src = photo.src.small;
              } else {
                el.src = `https://via.placeholder.com/50x50?text=${encodeURIComponent(word)}`;
              }
            })
            .catch(err => {
              console.error("Error fetching vocabulary image for", word, err);
              el.src = `https://via.placeholder.com/50x50?text=${encodeURIComponent(word)}`;
            });
        });
      }
      
      /* --- JUEGOS --- */
      
      // Muestra popup de selección de juego
      showGameSelectionPopup() {
  // 1) Validar que haya una historia cargada y que tenga array de juegos
  if (!this.currentStory || !Array.isArray(this.currentStory.games)) {
    console.warn("No hay ninguna historia activa o no se cargaron los juegos.");
    return;
  }

  // 2) Si llegó aquí, entonces sí existe currentStory.games
  const popup = document.createElement('div');
  popup.className = 'game-popup';

  let gameListHTML = `<h2>Selecciona un Juego</h2><ul>`;
  this.currentStory.games.forEach((gameObj) => {
    const gameKey = Object.keys(gameObj)[0];
    const gameData = gameObj[gameKey];

  gameListHTML += `
    <li data-game="${gameKey}">
      <span class="game-icon">
        <!-- Cambia "fa-gamepad" por el icono Font‑Awesome que prefieras -->
        <i class="fas fa-gamepad"></i>
     </span>
     ${gameData.title}
   </li>`;
  });
  gameListHTML += `</ul><button class="popup-close btn-professional">Cerrar</button>`;

  popup.innerHTML = gameListHTML;
  document.body.appendChild(popup);

  // Cerrar popup
  popup.querySelector('.popup-close').addEventListener('click', () => {
    popup.remove();
  });

  // Elegir juego
  popup.querySelectorAll('li').forEach(li => {
    li.style.cursor = 'pointer';
    li.addEventListener('click', () => {

          doneSound.currentTime = 0;
    doneSound.play();

      const selectedGame = li.getAttribute('data-game');
      popup.remove();
      this.startGame(selectedGame);
    });
  });
}
      
      // Inicia el juego seleccionado y muestra la vista de juego
      startGame(gameKey) {
        document.getElementById('storyView').style.display = 'none';
        document.getElementById('gameView').style.display = 'block';
        document.getElementById('gameContent').innerHTML = '';
        switch (gameKey) {
          case 'game1': this.launchOrderingSentencesGame(); break;
          case 'game2': this.launchTriviaGame(); break;
          case 'game3': this.launchMemoryCardsGame(); break;
          case 'game4': this.launchCompleteWordGame(); break;
          default: console.error('Juego no reconocido:', gameKey);
        }
      }
      
      // Sale del juego y vuelve a la vista de la historia
async exitGame() {
  // 1) Ocultar el juego y mostrar la vista de historias
  document.getElementById('gameView').style.display  = 'none';
  document.getElementById('storyView').style.display = 'block';

  // 2) Llamar a showStory para recargar la historia en this.currentStory,
  //    renderizar las tarjetas y dejar todo en su estado inicial
  await this.showStory(this.currentIndex);
}
      
      /* Juego 1: Ordenar Palabras */
      launchOrderingSentencesGame() {
        this.game1Index = 0;
        this.renderOrderingQuestion();
      }
      
      renderOrderingQuestion() {
  const gameData = this.currentStory.games.find(g => g.game1).game1;
  
  // Se combinan las oraciones guardadas (savedSentences) y las predeterminadas, colocando primero las guardadas
  let sentences = [];
  if (this.savedSentences.length > 0) {
    // Extraemos las oraciones guardadas
    sentences = this.savedSentences.map(item => item.sentence);
  }
  // Luego agregamos las oraciones por defecto
  sentences = sentences.concat([...gameData.sentences]);
  
  // Mostramos en consola la data final de oraciones
 
  
  // Actualizamos las traducciones para oraciones guardadas:
  this.savedSentences.forEach(item => {
    this.currentStory.translation[item.sentence.toLowerCase()] = item.translation;
  });
  
  // Verificamos si ya se han agotado todas las oraciones
  if (this.game1Index >= sentences.length) {
    document.getElementById('gameContent').innerHTML = `
      <div class="card ordering-game-card">
        <div class="card-header">
          <h2 class="ordering-game-title">${gameData.title}</h2>
          <div class="ordering-progress">${sentences.length}/${sentences.length}</div>
        </div>
        <div class="card-body">
          <p>Juego terminado. ¡Felicidades!</p>
        </div>
      </div>`;
    return;
  }
  
  // Se obtiene la oración actual (ya sea de las guardadas o predeterminadas)
  const sentence = sentences[this.game1Index];

  
  this.correctWords = sentence.split(" ");
  
  // Se crea la pool de palabras mezcladas
  this.availablePoolWords = this.shuffleArray([...this.correctWords]);
 
  
  this.orderingAnswer = [];
  
  const container = document.getElementById('gameContent');
  container.innerHTML = `
    <div class="card ordering-game-card">
      <div class="card-header">
        <h2 class="ordering-game-title">${gameData.title}</h2>
        <div class="ordering-progress">${this.game1Index + 1}/${sentences.length}</div>
      </div>
      <div class="card-body">
        <p class="ordering-instruction"><strong>Ordena las palabras:</strong></p>
        <div class="pool ordering-word-pool"></div>
        <p class="ordering-response-title"><strong>Tu respuesta:</strong></p>
        <div class="answer ordering-answer-panel"></div>
        <p class="result ordering-result"></p>
        <button class="retry-btn">Reintentar</button>
      </div>
    </div>`;
  
  // Renderizamos la pool y la respuesta actual
  this.renderPool();
  this.renderOrderingAnswer();
  
  // Evento para "Reintentar": reinicia la respuesta y la pool
  const retryButton = document.querySelector('.retry-btn');
  retryButton.addEventListener('click', () => {
     doneSound.currentTime = 0;
  doneSound.play();

    this.orderingAnswer = [];
    this.availablePoolWords = this.shuffleArray([...this.correctWords]);
   
    this.renderPool();
    this.renderOrderingAnswer();
    document.querySelector('.ordering-result').textContent = '';
  });
}





renderPool() {
  const poolContainer = document.querySelector('.ordering-word-pool');
  poolContainer.innerHTML = this.availablePoolWords
    .map((word, idx) => `<button class="word-btn" data-index="${idx}">${word}</button>`)
    .join('');
  
  // Asignar evento a cada botón: al hacer click, se remueve la palabra de la pool y se agrega a la respuesta.
  poolContainer.querySelectorAll('.word-btn').forEach(btn => {
    btn.addEventListener('click', () => {
     

       const word = btn.textContent.trim();
    const utterance = new SpeechSynthesisUtterance(word);
    utterance.lang = 'en-US';             // <-- fuerza inglés americano
    // (opcional) puedes elegir una voz concreta en inglés:
    // const voices = speechSynthesis.getVoices();
    // utterance.voice = voices.find(v => v.lang.startsWith('en') && v.name.includes('Google US English'));
    speechSynthesis.speak(utterance);


      const idx = parseInt(btn.getAttribute('data-index'));
      const selectedWord = this.availablePoolWords.splice(idx, 1)[0];
      this.orderingAnswer.push({ word: selectedWord });
      // Re-renderizamos la pool y la respuesta
      this.renderPool();
      this.renderOrderingAnswer();
      // Si ya se han seleccionado todas las palabras, se compara la respuesta
      if (this.orderingAnswer.length === this.correctWords.length) {
        const userSentence = this.orderingAnswer.map(item => item.word).join(" ");
        const correctSentence = this.correctWords.join(" ");
        const resultP = document.querySelector('.ordering-result');
        if (userSentence.trim() === correctSentence.trim()) {
          resultP.textContent = '¡Correcto!';
          setTimeout(() => { 
            this.game1Index++; 
            this.renderOrderingQuestion(); 
          }, 1500);
        } else {
          resultP.textContent = 'Orden incorrecto, intenta de nuevo.';
        }
      }
    });
  });
}



renderOrderingAnswer() {
  const answerDiv = document.querySelector('.ordering-answer-panel');
  let displayAnswer = [];
  let i = 0;
  // Recorremos el arreglo de respuesta y combinamos dos palabras si forman un phrasal.
  while(i < this.orderingAnswer.length) {
    let word = this.orderingAnswer[i].word;
    let translation = "";
    if (this.currentStory && this.currentStory.translation) {
      translation = this.currentStory.translation[word.toLowerCase()] || "";
    }
    // Si hay siguiente palabra, probar a combinar para ver si es un phrasal
    if (i < this.orderingAnswer.length - 1) {
      let potential = word + " " + this.orderingAnswer[i+1].word;
      if (this.currentStory && this.currentStory.translation && this.currentStory.translation[potential.toLowerCase()]) {
        let combinedTranslation = this.currentStory.translation[potential.toLowerCase()];
        displayAnswer.push({ type: "phrasal", indices: [i, i+1], word: potential, translation: combinedTranslation });
        i += 2;
        continue;
      }
    }
    displayAnswer.push({ type: "single", index: i, word: word, translation: translation });
    i++;
  }
  
  // Construimos el HTML para el panel de respuesta
  let answerHTML = "";
  displayAnswer.forEach(item => {
    if (item.type === "phrasal") {
      answerHTML += `<span data-index="${item.indices[0]}" data-count="2" style="margin: 0 5px; cursor: pointer; display: inline-block; text-align: center;">
            <div class="answer-word">${item.word}</div>
            <div class="answer-translation">${
  item.translation && item.translation.trim() !== "" 
    ? item.translation 
    : "-"
}</div>
        </span>`;
    } else {
      answerHTML += `<span data-index="${item.index}" data-count="1" style="margin: 0 5px; cursor: pointer; display: inline-block; text-align: center;">
            <div class="answer-word">${item.word}</div>
           <div class="answer-translation">${
  item.translation && item.translation.trim() !== "" 
    ? item.translation 
    : "-"
}</div>
        </span>`;
    }
  });
  answerDiv.innerHTML = answerHTML;
  
  // Permite eliminar la palabra o el grupo (phrasal) al hacer click, regresándola a la pool
  answerDiv.querySelectorAll('span').forEach(span => {
    span.addEventListener('click', () => {
      const startIndex = parseInt(span.getAttribute('data-index'));
      const count = parseInt(span.getAttribute('data-count'));
      // Recuperamos las palabras que se van a remover (en orden original)
      const removed = this.orderingAnswer.splice(startIndex, count);
      // Agregamos las palabras removidas de vuelta a la pool (al final) y remezclamos
      this.availablePoolWords = this.availablePoolWords.concat(removed.map(item => item.word));
      this.availablePoolWords = this.shuffleArray(this.availablePoolWords);
      this.renderPool();
      this.renderOrderingAnswer();
    });
  });
}
  
      
      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }
      
      /* Juego 2: Trivia */
      launchTriviaGame() {
        const gameData = this.currentStory.games.find(g => g.game2).game2;
        this.currentTriviaIndex = 0;
        this.triviaScore = 0;
        const container = document.getElementById('gameContent');
        container.innerHTML = `
          <div id="game2Container"></div>`;
        this.renderTriviaQuestion();
      }
      
      renderTriviaQuestion() {
  const gameData = this.currentStory.games.find(g => g.game2).game2;
  const container = document.getElementById('game2Container');
  if (this.currentTriviaIndex >= gameData.questions.length) {
    container.innerHTML = `
      <div class="card trivia-game-card">
        <div class="card-header">
          <h2 class="trivia-game-title">${gameData.title}</h2>
          <div class="trivia-progress">${gameData.questions.length}/${gameData.questions.length}</div>
        </div>
        <div class="card-body">
          <p>Juego terminado. Puntaje: ${this.triviaScore} de ${gameData.questions.length}</p>
        </div>
      </div>`;
    return;
  }
  
  const questionObj = gameData.questions[this.currentTriviaIndex];
  container.innerHTML = `
    <div class="card trivia-game-card">
      <div class="card-header">
        <h2 class="trivia-game-title">${gameData.title}</h2>
        <div class="trivia-progress">${this.currentTriviaIndex + 1}/${gameData.questions.length}</div>
      </div>
      <div class="card-body">
        <div class="question">${questionObj.question}</div>
        <div class="options trivia-options">
          ${questionObj.options.map(option => `<button class="word-btn" data-option="${option}">${option}</button>`).join('')}
        </div>
        <p class="result trivia-result"></p>
      </div>
    </div>`;
  
  // Reproduce la pregunta en voz alta.
  this.speakText(questionObj.question);
  
  // Asigna eventos a cada opción.
  container.querySelectorAll('.trivia-options button').forEach(btn => {
    btn.addEventListener('click', () => {
      const selected = btn.getAttribute('data-option');
      this.speakText(selected);
      const resultP = container.querySelector('.trivia-result');
      if (selected === questionObj.correct_answer) {
        resultP.textContent = '¡Correcto!';
        resultP.classList.add('animate-correct');
      } else {
        resultP.textContent = 'Incorrecto';
        resultP.classList.add('animate-incorrect');
      }
      setTimeout(() => {
        resultP.classList.remove('animate-correct', 'animate-incorrect');
        this.currentTriviaIndex++;
        this.renderTriviaQuestion();
      }, 1500);
    });
  });
}
      
      /* Juego 3: Memory Cards (Se mantiene sin cambios) */
      launchMemoryCardsGame() {
  const gameData = this.currentStory.games.find(g => g.game3).game3;
  
  // Obtenemos el vocabulario por defecto del juego 3
  let vocabulary = [...gameData.vocabulary];
  
  // Si hay palabras guardadas, se agregan al vocabulario
  if (this.savedWords.length > 0) {
    vocabulary = vocabulary.concat(this.savedWords.map(item => item.word));
  }
  
  // Eliminamos duplicados (comparando en minúsculas)
  vocabulary = [...new Set(vocabulary.map(word => word.toLowerCase()))];
  
  // Mostramos en consola el vocabulario final que se usará

  
  // Creamos las tarjetas (duplicadas para formar parejas)
  let cards = [];
  vocabulary.forEach((word, index) => {
    cards.push({ pairId: index, word: word });
    cards.push({ pairId: index, word: word });
  });
  
  // Se mezclan las tarjetas
  cards = this.shuffleArray(cards);
  
  // Mostramos en consola la data de las tarjetas
  
  const container = document.getElementById('gameContent');
  container.innerHTML = `<h2 class="memorytitle">${gameData.title}</h2>
    <div id="game3Container" class="memory-cards-container" style="position: relative;">
      ${cards.map((card, i) => {
        return `<div class="memory-card" data-pair="${card.pairId}" data-index="${i}">
                  <div class="card-back">?</div>
                  <div class="card-face">
                    <div class="card-image" data-query="${card.word}"></div>
                    <div class="card-text">${card.word}</div>
                  </div>
                </div>`;
      }).join('')}
    </div>
    <p id="memoryResult"></p>`;
  
  // Se asignan los eventos para cada tarjeta
  this.cards = Array.from(document.querySelectorAll('.memory-card'));
  this.memoryTotalPairs = this.cards.length / 2;  // ← Número de pares a encontrar :contentReference[oaicite:0]{index=0}

  this.cards.forEach(cardEl => {
    cardEl.addEventListener('click', () => {
      const word = cardEl.querySelector('.card-text').textContent;
      this.speakText(word);
      this.handleMemoryCardClick(cardEl);
    });
  });
  
  this.loadMemoryCardImages();
}

      
      handleMemoryCardClick(cardEl) {
        if (this.memoryLock || cardEl.classList.contains('flipped') || cardEl.classList.contains('matched')) return;
        cardEl.querySelector('.card-back').style.display = 'none';
        cardEl.querySelector('.card-face').style.display = 'block';
        cardEl.classList.add('flipped');
        if (!this.memoryFirstCard) {
          this.memoryFirstCard = cardEl;
        } else {
   if (cardEl.getAttribute('data-pair') === this.memoryFirstCard.getAttribute('data-pair')) {
  // Guardamos la referencia a la “primera” carta
  const firstCard = this.memoryFirstCard;

  // 1) Marcamos ambas como matched
  cardEl.classList.add('matched');
  firstCard.classList.add('matched');

  // 2) SONIDO de felicitación
  congratsSound.currentTime = 0;
  congratsSound.play();

  // 3) ANIMACIÓN de brillo en ambas
  cardEl.classList.add('matched-glow');
  firstCard.classList.add('matched-glow');

  // Quitar el glow tras la animación, usando la referencia capturada
  setTimeout(() => {
    cardEl.classList.remove('matched-glow');
    firstCard.classList.remove('matched-glow');
  }, 800);

  // 4) Actualizamos contador y reseteamos this.memoryFirstCard
  this.memoryMatches++;
  this.memoryFirstCard = null;

  // 5) Si ya no quedan pares, mostramos “¡Ganaste!”
if (this.memoryMatches === this.memoryTotalPairs) {
  // 1) Sonido de victoria
  victorySound.currentTime = 0;
  victorySound.play();

  // 2) Explosión de estrellitas
  const board = document.querySelector('#game3Container');
  burstStars(board, 30);

  // 3) Crear y mostrar el modal de felicitaciones
  const modal = document.createElement('div');
  modal.className = 'victory-modal';
  modal.textContent = '🎉 ¡Felicidades! Todos los pares encontrados 🎉';
  board.appendChild(modal);
  
setTimeout(() => {
  modal.remove(); // elimina el nodo del DOM
}, 4000);

}

}
          
          else {
            this.memoryLock = true;
            setTimeout(() => {
              cardEl.querySelector('.card-back').style.display = 'flex';
              cardEl.querySelector('.card-face').style.display = 'none';
              cardEl.classList.remove('flipped');
              this.memoryFirstCard.querySelector('.card-back').style.display = 'flex';
              this.memoryFirstCard.querySelector('.card-face').style.display = 'none';
              this.memoryFirstCard.classList.remove('flipped');
              this.memoryFirstCard = null;
              this.memoryLock = false;
            }, 1000);
          }
        }
      }
      
      loadMemoryCardImages() {
        const imgContainers = document.querySelectorAll('.card-image');
        imgContainers.forEach(el => {
          const query = el.getAttribute('data-query');
axios.get(
  `${PEXELS_BASE}/search?query=${encodeURIComponent(query)}&per_page=1`
)            .then(response => {
              if (response.data.photos && response.data.photos.length > 0) {
                const photo = response.data.photos[0];
                el.innerHTML = `<img src="${photo.src.small}" alt="${query}" style="width:100%; height:100%; object-fit:cover;">`;
              } else {
                el.innerHTML = `<img src="https://via.placeholder.com/100x80?text=${encodeURIComponent(query)}" alt="${query}">`;
              }
            })
            .catch(err => {
              console.error("Error fetching image for memory card:", query, err);
              el.innerHTML = `<img src="https://via.placeholder.com/100x80?text=${encodeURIComponent(query)}" alt="${query}">`;
            });
        });
      }
      
      /* Juego 4: Completa la Palabra */
      launchCompleteWordGame() {
  const gameData = this.currentStory.games.find(g => g.game4).game4;
  this.currentFillIndex = 0;
  this.fillScore = 0;
  // Inicializa currentFillData para la primera pregunta
  this.currentFillData = this.generateFillData(gameData.questions[this.currentFillIndex].answer);
  const container = document.getElementById('gameContent');
  container.innerHTML = `
    <div id="game4Container" class="completa-game-card">
      <h2>${gameData.title}</h2>
      <div class="incomplete-sentence">${gameData.questions[this.currentFillIndex].sentence}</div>
      <div class="fill-answer" id="fillAnswerArea">
        ${this.currentFillData.fillWords.map(wordData => {
          return wordData.display.map(char => `<span>${char === null ? '_' : char}</span>`).join('');
        }).join('&nbsp;&nbsp;')}
      </div>
      <div class="letter-pool" id="letterPool">
        ${this.currentFillData.pool.map((letter, i) => `<button class="btn-professional" data-index="${i}">${letter}</button>`).join('')}
      </div>
      <button id="resetFillBtn" class="action-btn btn-professional">Reiniciar</button>
      <p id="fillFeedback"></p>
    </div>`;
  
  // Ahora renderFillQuestion() encontrará el contenedor "game4Container"
  this.renderFillQuestion();
}




      generateFillData(answer) {
        answer = answer.toUpperCase();
        const words = answer.split(" ");
        const fillWords = words.map(word => {
          if (word.length <= 2) return { original: word, display: word.split(''), missingIndices: [] };
          const numMissing = Math.ceil(word.length / 3);
          let possible = [];
          for (let i = 1; i < word.length - 1; i++) { possible.push(i); }
          let missingIndices = [];
          while (missingIndices.length < numMissing && possible.length > 0) {
            const randIndex = Math.floor(Math.random() * possible.length);
            missingIndices.push(possible[randIndex]);
            possible.splice(randIndex, 1);
          }
          missingIndices.sort((a, b) => a - b);
          const display = word.split('').map((char, idx) => missingIndices.includes(idx) ? null : char);
          return { original: word, display, missingIndices };
        });
        let missingLetters = [];
        fillWords.forEach(wordData => {
          wordData.missingIndices.forEach(idx => { missingLetters.push(wordData.original[idx]); });
        });
        const distractorTarget = missingLetters.length + 3;
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        while (missingLetters.length < distractorTarget) {
          const randChar = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
          missingLetters.push(randChar);
        }
        missingLetters = this.shuffleArray(missingLetters);
        return { fillWords, pool: missingLetters };
      }
      
      renderFillQuestion() {
  const container = document.getElementById('game4Container');
  if (!container) {
    console.error('No se encontró el contenedor con id "game4Container"');
    return;
  }
  
  const gameData = this.currentStory.games.find(g => g.game4).game4;
  if (this.currentFillIndex >= gameData.questions.length) {
    container.innerHTML = `<p>Juego terminado. Puntaje: ${this.fillScore} de ${gameData.questions.length}</p>`;
    return;
  }
  
  const questionObj = gameData.questions[this.currentFillIndex];
  this.currentFillData = this.generateFillData(questionObj.answer);
  container.innerHTML = `
    <div class="question">Completa la palabra:</div>
    <div class="incomplete-sentence">${questionObj.sentence}</div>
    <div class="fill-answer" id="fillAnswerArea">
      ${this.currentFillData.fillWords.map(wordData => {
        return wordData.display.map(char => `<span>${char === null ? '_' : char}</span>`).join('');
      }).join('&nbsp;&nbsp;')}
    </div>
    <div class="letter-pool" id="letterPool">
      ${this.currentFillData.pool.map((letter, i) => `<button class="btn-professional" data-index="${i}">${letter}</button>`).join('')}
    </div>
    <button id="resetFillBtn" class="action-btn btn-professional">Reiniciar</button>
    <p id="fillFeedback"></p>
  `;
  
  const poolButtons = container.querySelectorAll('#letterPool button');
  poolButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const letter = btn.textContent;
      this.speakText(letter);
      const answerSpans = container.querySelectorAll('#fillAnswerArea span');
      for (let span of answerSpans) {
        if (span.textContent === '_') {
          span.textContent = letter;
          btn.disabled = true;
          break;
        }
      }
      this.checkFillCompletion();
    });
  });
  
  document.getElementById('resetFillBtn').addEventListener('click', () => {
    const answerSpans = container.querySelectorAll('#fillAnswerArea span');
    let idx = 0;
    this.currentFillData.fillWords.forEach(wordData => {
      wordData.display.forEach((char) => {
        answerSpans[idx].textContent = (char === null) ? '_' : char;
        idx++;
      });
    });
    container.querySelectorAll('#letterPool button').forEach(btn => btn.disabled = false);
  });
}


      
      checkFillCompletion() {
        const container = document.getElementById('game4Container');
        const answerSpans = container.querySelectorAll('#fillAnswerArea span');
        let currentAnswer = "";
        answerSpans.forEach(span => { currentAnswer += span.textContent; });
        if (!currentAnswer.includes('_')) {
          let idx = 0, reconstructed = "";
          this.currentFillData.fillWords.forEach(wordData => {
            let wordStr = "";
            for (let i = 0; i < wordData.original.length; i++) {
              wordStr += answerSpans[idx].textContent;
              idx++;
            }
            reconstructed += wordStr + " ";
          });
          reconstructed = reconstructed.trim();
          const feedback = container.querySelector('#fillFeedback');
          const gameData = this.currentStory.games.find(g => g.game4).game4;
          const questionObj = gameData.questions[this.currentFillIndex];
          if (reconstructed === questionObj.answer.toUpperCase()) {
            feedback.textContent = '¡Correcto!';
            this.fillScore++;
          } else {
            feedback.textContent = 'Incorrecto, intenta de nuevo.';
          }
          setTimeout(() => {
            this.currentFillIndex++;
            this.renderFillQuestion();
          }, 1500);
        }
      }






    }
    




    function showSpinner() {
   const spinner = document.querySelector('.loading-screen');
 // si ya está en el DOM, no hacemos appendChild; solo lo mostramos
spinner.style.display = 'flex';  // coincide con el CSS
 // y reiniciamos el porcentaje a 0%
 const txt = document.getElementById('loadingText');
 if (txt) txt.textContent = 'Cargando… 0%';
}

function hideSpinner() {
  const spinner = document.querySelector('.loading-screen');
  spinner.style.display = 'none';
}


window.speechSynthesis.onvoiceschanged = function() {
  const voces = window.speechSynthesis.getVoices();
 
};





let model = null;

// Carga el modelo antes de iniciar la app
(async () => {
  // ruta a tu modelo (ajusta si es distinta)
  model = await Vosk.createModel('model/downloaded.tar.gz');
 
  // Ahora que model existe, instanciamos
  new StoryManager();
})();















  </script>
</body>
</html>
